<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
  <head>
    <meta charset='utf-8'/>
    <title>Shadow DOM 中文规范</title>
    <script src='./autolink-config.js' class='remove'></script>
    <script src='../../assets/scripts/autolink.js' class='remove'></script>
    <link rel="stylesheet" href="../../assets/styles/respec-complement.css" type="text/css" />
    <script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "ED",
          shortName: "shadow-dom",
          editors: [{ name: "Dimitri Glazkov", url: "mailto:dglazkov@chromium.org", company: "Google, Inc." },
                    { name: "Hayato Ito", url: "mailto:hayato@google.com", company: "Google, Inc." }],
          wg: "W3C Web Applications (WebApps)",
          wgURI: "http://www.w3.org/2008/webapps/",
          wgPublicList: "public-webapps",
          wgPatentURI: "",
          edDraftURI: "http://w3c.github.io/webcomponents/spec/shadow/",
          otherLinks: [
              {
                  key: "Revision history",
                  href: "https://github.com/w3c/webcomponents/commits/gh-pages/spec/shadow/"
              }
          ],
          localBiblio: {
              "SELECTORS4": {
                  title: "Selectors Level 4",
                  href: "http://dev.w3.org/csswg/selectors4/",
                  authors: ["Elika Etemad", "Tab Atkins Jr"],
                  status: "ED"
              },
              "DOMPARSING": {
                  title: "DOM Parsing and Serialization",
                  href: "http://domparsing.spec.whatwg.org/",
                  authors:  ["Ms2ger"]
              },
              "EDITING": {
                  title: "HTML Editing APIs",
                  href: "https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html",
                  authors:  ["Aryeh Gregor"]
              }
          }
      };
      var bugAssistConfig = {
          blocked: '14978',
          short_desc: '[Shadow]: ',
          product: 'WebAppsWG',
          component: 'Component Model'
      };
    </script>
    <script src="../../assets/scripts/bug-assist.js" class="remove"></script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification describes a method of combining multiple DOM trees into one hierarchy and how these trees interact with each other within a document, thus
        enabling better composition of the DOM.
      </p>
    </section>

    <section id='sotd'>
    </section>

    <section>
      <h2>Conformance</h2>

      <p>All diagrams, examples, notes, are non-normative, as well as sections explicitly marked as non-normative. Everything else in this specification is normative.</p>

      <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in [[!RFC2119]]. For readability, these words do not appear in all uppercase letters in this specification.</p>

      <p>To help with layering and to avoid circular dependencies between various parts of specification, this document consists of three consecutive narratives:</p>
      <ol>
        <li>setting up the stage for the specification,</li>
        <li>explaining of the conceptual model and algorithms behind it, and</li>
        <li>expressing this model with DOM interfaces and HTML elements.</li>
      </ol>

      <p>In a sense, these parts can be viewed as <em>math</em>, which sets up the reasoning environment, <em>physics</em>, which is the theoretical reasoning about the concept, and <em>mechanics</em>, which is the practical application of this reasoning.</p>

      <p>Any point, at which a conforming UA must make decisions about the state or reaction to the state of the conceptual model, is captured as <a href="http://en.wikipedia.org/wiki/Algorithm">algorithm</a>. The algorithms are defined in terms of processing equivalence. The <dfn>processing equivalence</dfn> is a constraint imposed on the algorithm implementors, requiring the output of the both UA-implemented and the specified algorithm to be exactly the same for all inputs.</p>
    </section>

    <section>
      <h2>Concepts</h2>

      <section class="informative">
        <h3>Introduction</h3>

        <p>
          See the <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a> as a non-normative intruduction.
        </p>
      </section>

      <section>
        <h3>Shadow trees</h3>

        <p>A <dfn>document tree</dfn> is a <a>node tree</a> [[!DOM]] whose <a>root</a> <a>node</a> is a <a>document</a>.</p>

        <p>Any element can have an <dfn title="shadow roots list">associated ordered list</dfn> of zero or more <a title="node tree">node trees</a>.</p>

        <p>An element <dfn>hosts</dfn> a <a>node tree</a> if the <a>node tree</a> is a member of this associated list.</p>

        <p>A <dfn>shadow host</dfn> is an element that <a>hosts</a> one or more <a title="node tree">node trees</a>.</p>

        <p>A <dfn>shadow tree</dfn> is a <a>node tree</a> <a title="hosts">hosted</a> by a <a>shadow host</a>.</p>

        <p>A <dfn>shadow root</dfn> is the <a>root</a> <a>node</a> of a shadow tree.</p>

        <p>If more than one <a>shadow tree</a> is <a title="hosts">hosted</a> by the same <a>shadow host</a>, the more recently added <a>shadow tree</a> is called the <dfn>younger shadow tree</dfn> and the less recently added <a>shadow tree</a> is called the <dfn>older shadow tree</dfn>.</p>

        <p>If there is no <a>older shadow tree</a> than a given <a>shadow tree</a>,
          the <a>shadow tree</a> is called the <dfn>oldest shadow tree</dfn>.</p>

        <p>If there is no <a>younger shadow tree</a> than a given <a>shadow tree</a>,
          the <a>shadow tree</a> is called the <dfn>youngest shadow tree</dfn>.</p>

        <p>The <dfn>older shadow root</dfn> is the root node of the <a>older shadow tree</a>.</p>

        <p>The <dfn>younger shadow root</dfn> is the root node of the <a>younger shadow tree</a>.</p>

        <p>The <dfn>oldest shadow root</dfn> is the root node of the <a>oldest shadow tree</a>.</p>

        <p>The <dfn>youngest shadow root</dfn> is the root node of the <a>youngest shadow tree</a>.</p>

        <p class="note">
          For convenience, the <a>shadow root</a> provides its own set of <a title="DOM tree accessors">DOM tree accessor</a> methods.
          No <a title="node">nodes</a> other than the <a>shadow root</a> descendants are accessible with these methods.
        </p>
      </section>

      <section>
        <h3>Trees of trees</h3>

        <p>A <dfn>tree of trees</dfn> is a <a>tree</a> of <a title="node tree">node trees</a>.</p>

        <p class="note">
          The purpose of introducing a tree of trees here is to define algorithms easily in the following sections.
          This is a kind of a notation techchique to make the this specification simpler.
        </p>

        <p>Just like a <a>node tree</a> is defined as <a title="tree">a set of relationships</a> between <a title="node">nodes</a>,
          a <a>tree of trees</a> is similarly defined as a set of relationships between <a title="node tree">node trees</a>:</p>
        <ul>
          <li>
            A <a>node tree</a> <var>A</var> is called a <dfn>parent tree</dfn> of a <a>node tree</a> <var>B</var> if either of the following conditions is satisfied:
            <ul>
              <li><var>A</var> and <var>B</var> are next to each other in the same <a title="shadow roots list">associated ordered list</a> and <var>A</var> is the <a>older shadow tree</a> relative to <var>B</var>.</li>
              <li><var>B</var> is the <a>oldest shadow tree</a> and <a>shadow host</a> of <var>B</var> participates in <var>A</var>.</li>
            </ul>

          </li>
          <li>If there is more than one <a>node tree</a> that shares the same <a>parent tree</a>, the <a>tree order</a> between them in the <a>tree of trees</a> is defined as follows:
            <ol>
              <li>Let <var>A</var> and <var>B</var> be <a title="node tree">node trees</a> that share the same <a>parent tree</a>.</li>
              <li><var>A</var> comes before <var>B</var> if either of the following conditions is satisfied:
                <ul>
                  <li>The <a>shadow host</a> which <a>hosts</a> <var>A</var> is <a>preceding</a> the <a>shadow host</a> which <a>hosts</a> <var>B</var>.</li>
                  <li><var>B</var> is not the <a>oldest shadow tree</a>.</li>
                </ul>
              </li>
            </ol>
          </li>
          <li>Other relationships and terms, such as <dfn>root tree</dfn>, <dfn>child tree</dfn>,
            <dfn>descendant tree</dfn>, <dfn>inclusive descendant tree</dfn>,
            <dfn>ancestor tree</dfn>, <dfn>inclusive ancestor tree</dfn>,
            <dfn>preceding tree</dfn>
            are defined in the similar way as defined in <a title="tree">trees</a>.</li>
        </ul>

        <p>The <a><code>ownerDocument</code></a> property of a <a>node</a> in a shadow tree <strong>must</strong> refers to the <a>document</a> of the <a>shadow host</a> which <a>hosts</a> the shadow tree.</p>

        <p><a><code>Window</code></a> object <a title="named access on the window object">named properties</a> [[!HTML]] <strong>must</strong> access the <a title="node">nodes</a> in the <a>document tree</a>.</p>

        <section class="informative">
          <h3>Example tree of trees</h3>

          <figure>
            <object data="../../assets/images/tree-of-trees.svg" width="650" height="823"></object>
            <figcaption>
              A tree of trees.
            </figcaption>
          </figure>

          <p>
            In the figure, there are seven node trees, named A, B, C, D, E and F.
            The node trees, C, D and E, are hosted by the same <a>shadow host</a>, which participates in the node tree A.
            The node tree C is the <a>oldest shadow tree</a>. The node tree E is the <a>youngest shadow tree</a>.
            The following set of relationships holds in the figure:
            <ul>
              <li>The ordered list of A's <a title="child tree">child trees</a> is [B, C].</li>
              <li>The ordered list of B's <a title="child tree">child trees</a> is [].</li>
              <li>The ordered list of C's <a title="child tree">child trees</a> is [F, D].</li>
              <li>The ordered list of D's <a title="child tree">child trees</a> is [E].</li>
              <li>The ordered list of E's <a title="child tree">child trees</a> is [].</li>
            </ul>
        </section>

      </section>

      <section>
        <h3>Composed trees</h3>

        <p>A <dfn>composed tree</dfn> is a <a>node tree</a> which is constructed out of <a title="node">nodes</a> from multiple <a title="node tree">node trees</a> in a <a>tree of trees</a>.
          The exact algorithm of constructing a composed tree is specified later.</p>

        <figure>
          <object data="../../assets/images/composed-tree.svg" width="654" height="606"></object>
          <figcaption>A composed tree</figcaption>
        </figure>

        <p>In <dfn>rendering</dfn> a <a>document tree</a>, or presenting it visually, the <a>composed tree</a> <strong>must</strong> be used instead of the <a>document tree</a>.</p>

        <p>The <a>composed tree</a> <strong>must</strong> be updated before the <a>rendering</a> occurs.</p>
      </section>

    </section>

    <section>
      <h2>Distributions</h2>

      <section>
        <h3>Insertion Points</h3>

        <p>An <dfn>insertion point</dfn> is a defined location where <a title="node">nodes</a> in a different <a>node tree</a> appear instead of the nodes's original position when constructing a <a>composed tree</a>.</p>

        <figure>
          <object data="../../assets/images/distributions.svg" width="663" height="598"></object>
          <figcaption>A distribution</figcaption>
        </figure>

        <p>A <dfn>distribution</dfn> is the mechanism that determines which <a title="node">nodes</a> appear at each <a>insertion point</a>. The exact algorithm of a <a>distribution</a> is specified later.</p>
      </section>


      <section>
        <h3>Content Insertion Points</h3>

        <p>A <dfn>content insertion point</dfn> is an <a>insertion point</a> to where the child <a title="node">nodes</a> of the <a>shadow host</a> are distributed.
          The <a>content element</a> that satisfies all of the following conditions represents a <a>content insertion point</a>:</p>
        <ul>
          <li>The <a>root</a> <a>node</a> of the <a>content element</a> is a <a>shadow root</a></li>
          <li>There is no other <a>content element</a> in the <a title="ancestor">ancestors</a> of the <a>content element</a></li>
          <li>There is no <a>shadow element</a> in the <a title="ancestor">ancestors</a> of the <a>content element</a></li>
        </ul>
      </section>

      <section>
        <h3>Shadow Insertion Points</h3>

        <p>A <dfn>shadow insertion point</dfn> is an <a>insertion point</a> to where the children of the <a>older shadow root</a> are distributed.
          The <a>shadow element</a> that satisfies of the following conditions represents a <a>shadow insertion point</a>:</p>
        <ul>
          <li>The <a>root</a> <a>node</a> of the <a>shadow element</a> is a <a>shadow root</a></li>
          <li>There is no other <a>shadow element</a> which is <a>preceding</a> the <a>shadow element</a></li>
          <li>There is no other <a>content element</a> in the <a title="ancestor">ancestors</a> of the <a>shadow element</a></li>
        </ul>
      </section>

      <section>
        <h3>Distribution Results</h3>

        <p>Each <a>tree of trees</a> has the <dfn>distribution result</dfn> which describes the result of distributions.
          The <a>distribution result</a> <strong>must</strong> be <a title="processing equivalence">equivalent</a> of the following:</p>
        <ol>
          <li>Each <a>insertion point</a> has an ordered list, called <dfn>distributed nodes</dfn>, which consists of <a title="node">nodes</a> which are distributed into the <a>insertion point</a>.</li>
          <li>Each <a>node</a> that is not an <a>insertion point</a> has an ordered list, called <dfn>destination insertion points</dfn>, which consists of <a title="insertion point">insertion points</a> to where the <a>node</a> is distributed</li>
        </ol>

        <p>An <a>insertion point</a> <var>A</var> is the <dfn>final destination</dfn> of a <a>node</a> <var>B</var> if <var>A</var> is the last item of the <a>destination insertion points</a> of <var>B</var>.</p>

        <p>When a <a>node</a> <var>A</var> is <dfn title="distributes">distributed</dfn> into an <a>insertion point</a> <var>B</var>, the following steps <strong>must</strong> happen:</p>
        <ul>
          <li>Add <var>A</var> to the <a>distributed nodes</a> of <var>B</var></li>
          <li>Add <var>B</var> to the <a>destination insertion points</a> of <var>A</var></li>
        </ul>

        <div class="note">
          <p>One case that deserves special consideration is the situation when an <a>insertion point</a> is a child <a>node</a> of another <a>shadow host</a>. In such situations, the <a title="node">nodes</a> <a title="distributes">distributed</a> into that <a>insertion point</a> appear as if they were child <a title="node">nodes</a> of the <a>shadow host</a> in the context of <a>distribution</a>. Thus, the <a title="node">nodes</a> <a title="distributes">distributed</a> to a <a>shadow tree</a> could have already been <a title="distributes">distributed</a> from its parent tree.</p>

          <p>Despite being distributed to more than one insertion point, a node still only appears once in the composed tree at the final destination.</p>
        </div>

        <figure>
          <object data="../../assets/images/re-distributions.svg" width="693" height="822"></object>
          <figcaption>A re-distribution.
            In the figure, a node <em>child 1</em> is distributed into <em>insertion point 1</em>. Then <em>child1</em> is re-distributed into <em>insertion point 3</em>.
            The destination insertion points of <em>child 1</em> is [<em>insertion point 1</em>, <em>insertion point 3</em>] and <em>insertion point 3</em> is the final destination of <em>child 1</em>.
            The distributed nodes of <em>insertion point 1</em> and <em>insertion point 3</em> is [<em>child 1</em>] and [<em>child 1</em>, <em>child 3</em>], respectively.
          </figcaption>
        </figure>

      </section>

      <section>
        <h3>Distribution Algorithms</h3>

        <p>The <dfn>distribution algorithm</dfn> <strong>must</strong> be used to determine the <a>distribution result</a> for a <a>tree of trees</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>TREE-OF-TREES</var>, a <a>tree of trees</a></dd>
            <dt>Output</dt>
            <dd>The <a>distribution result</a> of <var>TREE-OF-TREES</var> is updated</dd>
          </dl>
          <ol>
            <li>Let all <a>distributed nodes</a> and <a>destination insertion points</a> owned by <a title="node">nodes</a> in <var>TREE-OF-TREES</var> be empty</li>
            <li>Let <var>ROOT-TREE</var> be the <a>root tree</a> of <var>TREE-OF-TREES</var></li>
            <li>Run the <a>distribution resolution algorithm</a> with <var>ROOT-TREE</var> as input</li>
          </ol>
        </div>

        <p>The <dfn>distribution resolution algorithm</dfn> <strong>must</strong> be used to determine the <a>distribution result</a> for a given <a>node tree</a> and its <a title="descendant tree">descendant trees</a>, and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE-TREE</var>, a <a>node tree</a></dd>
            <dt>Output</dt>
            <dd>The <a>distribution result</a> is updated for the <a title="inclusive descendant tree">inclusive descendant trees</a> of <var>NODE-TREE</var></dd>
          </dl>

          <ol>
            <li>For each <a>shadow host</a>, <var>SHADOW-HOST</var>, which participates in <var>NODE-TREE</var>, in <a>tree order</a>:
              <ol>
                <li>Let <var>POOL</var> be the result of the <a>pool population algorithm</a> with <var>SHADOW-HOST</var> as input</li>
                <li>For each <a>shadow tree</a>, <var>SHADOW-TREE</var>, which <var>SHADOW-HOST</var> <a>hosts</a>, in order from the <a>youngest shadow tree</a> to the <a>oldest shadow tree</a>:
                  <ol>
                    <li>Run the <a>pool distribution algorithm</a> with <var>SHADOW-TREE</var> and <var>POOL</var> as input</li>
                  </ol></li>
                <li>For each <a>shadow tree</a>, <var>SHADOW-TREE</var>, that <var>SHADOW-HOST</var> <a>hosts</a>, in order from the <a>oldest shadow tree</a> to the <a>youngest shadow tree</a>:
                  <ol>
                    <li>Let <var>SHADOW</var> be the <a>shadow insertion point</a> which participates in <var>SHADOW-TREE</var></li>
                    <li>If such a <var>SHADOW</var> exits:
                      <ol>
                        <li>If <var>SHADOW-TREE</var> is not the <a>oldest shadow tree</a>:
                          <ol>
                            <li>Let <var>POOL</var> be the result of the <a>pool population algorithm</a> with the root node of the <a>older shadow tree</a> relative to <var>SHADOW-TREE</var> as input.</li>
                          </ol></li>
                        <li>For each <a>node</a>, <var>CHILD</var>, in <var>POOL</var>
                          <ol>
                            <li><a title="distributes">Distribute</a> <var>CHILD</var> into <var>SHADOW</var></li>
                          </ol></li>
                      </ol></li>
                    <li>Run the <a>distribution resolution algorithm</a>, recursively, with <var>SHADOW-TREE</var> as input</li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p>The <dfn>pool population algorithm</dfn> <strong>must</strong> be used to populate <a title="node">nodes</a> from the child <a title="node">nodes</a> of a given <a>node</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE</var>, a node</dd>
            <dt>Output</dt>
            <dd><var>POOL</var>, an ordered list of nodes</dd>
          </dl>

          <ol>
            <li>Let <var>POOL</var> be an empty ordered list.</li>
            <li>For each child <a>node</a>, <var>CHILD</var>, of <var>NODE</var>:
              <ol>
                <li>If <var>CHILD</var> is an <a>insertion point</a>:
                  <ol>
                    <li>Add all <a title="node">nodes</a> in the <a>distributed nodes</a> of <var>CHILD</var> to <var>POOL</var></li>
                  </ol></li>
                <li>Otherwise:
                  <ol>
                    <li>Add <var>CHILD</var> to <var>POOL</var></li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p>The <dfn>pool distribution algorithm</dfn> <strong>must</strong> be used to distribute <a title="node">nodes</a> in a pool into the <a title="content insertion point">content insertion points</a> in a <a>shadow tree</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>SHADOW-TREE</var>, a shadow tree</dd>
            <dd><var>POOL</var>, an ordered list of nodes</dd>
            <dt>Output</dt>
            <dd>Nodes in POOL are distributed into the content insertion points in the tree.</dd>
          </dl>

          <ol>
            <li>For each <a>content insertion point</a>, <var>CONTENT</var>, which participates in <var>SHADOW-TREE</var>, in tree order:
              <ol>
                <li>For each <a>node</a>, <var>NODE</var>, in <var>POOL</var>
                  <ol>
                    <li>If <var>NODE</var> satisfies <var>CONTENT</var>'s matching criteria:
                      <ol>
                        <li><a title="distributes">Distribute</a> <var>NODE</var> into <var>CONTENT</var></li>
                        <li>Remove <var>NODE</var> from <var>POOL</var></li>
                      </ol></li>
                  </ol></li>
                <li>If no <a title="node">nodes</a> are distributed to <var>CONTENT</var>:
                  <ol>
                    <li>For each child, <var>CHILD</var>, of <var>CONTENT</var>
                      <ol>
                        <li><a title="distributes">Distribute</a> <var>CHILD</var> into <var>CONTENT</var></li>
                      </ol></li>
                  </ol></li>
              </ol></li>
          </ol>

        </div>

        <p class="note">If no nodes are distributed into a <a>content insertion point</a> <var>CONTENT</var>, the child <a title="node">nodes</a> of <var>CONTENT</var> are distributed into <var>CONTENT</var> as fallback nodes.</p>

        <p>If any condition which affects the <a>distribution result</a> changes, the <a>distribution result</a> <strong>must</strong> be updated before any use of the <a>distribution result</a>.</p>

      </section>

      <section>
        <h3>Satisfying Matching Criteria</h3>

        <p>The <dfn>matching criteria</dfn> for an <a>insertion point</a> is a set of <a title="compound selector">compound selectors</a> [[!SELECTORS4]]. These <a title="compound selector">compound selectors</a> are restricted to contain only these <a title="simple selector">simple selectors</a>:</p>

        <ul>
          <li>A <a>type selector</a> or a <a>universal selector</a></li>
          <li><a title="class selector">class selector(s)</a></li>
          <li>An <a>ID selector</a></li>
          <li><a title="attribute selector">attribute selector(s)</a></li>
          <li>A <a>negation pseudo-class</a>, <code>:not()</code></li>
        </ul>

        <p>A <a>node</a> <dfn title="satisfies-matching-criteria">satisfies</dfn> a <a>matching criteria</a> only if:</p>
        <ol>
          <li>all <a title="compound selector">compound selectors</a> in the set, contain only the <a title="simple selector">simple selectors</a> specified above; and</li>
          <li>a <a>node</a> matches at least one <a title="compound selector">compound selectors</a> in the set or the set is empty.</li>
        </ol>
      </section>

    </section>

    <section>
      <h2>Composition</h2>

      <p>The <dfn>composed tree children calculation algorithm</dfn> <strong>must</strong> be used to determine the child <a title="node">nodes</a> of a <a>node</a> in the <a>composed tree</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

      <div class="algorithm">
        <dl>
          <dt>Input</dt>
          <dd><var>NODE</var>, a <a>node</a> which participates in a composed tree</dd>
          <dt>Output</dt>
          <dd><var>CHILDREN</var>, the child nodes of <var>NODE</var> in the <a>composed tree</a>.</dd>
        </dl>

        <ol>
          <li>Let <var>CHILDREN</var> be an empty ordered list of nodes</li>
          <li>If <var>NODE</var> is a <a>shadow host</a>:
            <ol>
              <li>Let <var>CHILD-POOL</var> be the children of the <a>youngest shadow root</a> which <var>NODE</var> <a>hosts</a>.</li>
            </ol></li>
          <li>Otherwise:
            <ol>
              <li>Let <var>CHILD-POOL</var> be the child <a title="node">nodes</a> of NODE</li>
            </ol></li>
          <li>For each <a>node</a>, <var>CHILD</var>, in <var>CHILD-POOL</var>:
            <ol>
              <li>If <var>CHILD</var> is an <a>insertion point</a>:
                <ol>
                  <li>For each <a>node</a>, <var>DISTRIBUTED-NODE</var>, in the <a>distributed nodes</a> of the <a>insertion point</a> <var>CHILD</var>:
                    <ol>
                      <li>If <var>CHILD</var> is the <a>final destination</a> of <var>DISTRIBUTED-NODE</var>, add <var>DISTRIBUTED-NODE</var> to <var>CHILDREN</var></li>
                    </ol></li>
                </ol></li>
              <li>Otherwise:
                <ol>
                  <li>Add <var>CHILD</var> to <var>CHILDREN</var></li>
                </ol></li>
            </ol></li>
        </ol>

      </div>

      <p>For a given <a>tree of trees</a> <var>TREE-OF-TREES</var>, the <a>composed tree</a> constructed from <var>TREE-OF-TREES</var> <strong>must</strong> be <a title="processing equivalence">equivalent</a> to the following tree:</p>
      <ul>
        <li>The <a>root</a> <a>node</a> of the <a>composed tree</a> is the <a>root</a> <a>node</a> of the <a>root tree</a> of <var>TREE-OF-TREES</var>.</li>
        <li>For a given <a>node</a> which <a>participates</a> in the <a>composed tree</a>, the child <a title="node">nodes</a> of the <a>node</a> is the result of the <a>composed tree children calculation algorithm</a> with the <a>node</a> as input.
        </li>
      </ul>
    </section>

    <section>
      <h2>事件</h2>

      <p>当一个<a>Event(事件)在<a>shadow tree</a>中</a>被<a title="event dispatch">dispatched(分发)</a>时, 事件的路径要么穿过<a title="shadow tree">shadow trees</a>要么在<a>shadow root</a>被终止. 其中一个例外情况就是<a title="mutation event">mutation events(突发事件)</a>. <a title="mutation event">mutation event types(突发事件)</a> <strong>一定</strong> 不能在<a>shadow tree</a>中被分发.</p>

      <section>
        <h3>通常会被阻止的事件</h3>

        <p><dfn title="events-always-stopped">following events(以下事件)</dfn> <strong>一定</strong>是通常会在<a>node tree(节点树)</a>的<a>root(根)</a> <a>node(节点)</a>被阻止:</p>
        <ul>
          <li><code>abort</code></li>
          <li><code>error</code></li>
          <li><code>select</code></li>
          <li><code>change</code></li>
          <li><code>load</code></li>
          <li><code>reset</code></li>
          <li><code>resize</code></li>
          <li><code>scroll</code></li>
          <li><code>selectstart</code></li>
        </ul>
      </section>

      <section>
        <h3>事件路径</h3>

        <p><dfn>event path calculation algorithm(事件路径算法)</dfn>一定是被用来决定事件路径并且<strong>一定</strong>要通过下列步骤<a title="processing equivalence">(相当于以下的步骤的过程)</a>:</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>NODE(节点)</var>, 一个节点</dd>
            <dd><var>EVENT(事件)</var>, 一个事件</dd>
            <dt>输出</dt>
            <dd><var>PATH(路径)</var>, 一个事件的路径, 一个事件目标的顺序列表</dd>
          </dl>
          <ol>
            <li>让<var>PATH(路径)</var>成为一个暂时为空的节点列表(有顺序的)</li>
            <li>让<var>CURRENT(当前的事件目标)</var>作为<var>NODE(节点)</var></li>
            <li>增加<var>CURRENT(当前的事件目标)</var>的节点到<var>PATH(路径)</var>中</li>
            <li>如果存在<var>CURRENT(当前的事件目标)</var>则重复:
              <ol>
                <li>如果<var>CURRENT(当前)</var>的<a>目标插入点</a>不为空:
                  <ol>
                    <li>对于每一个<a>insertion point(插入点)</a>, <var>INSERTION-POINT(插入点)</var>, 在<var>CURRENT(当前的)</var><a>destination insertion points(目标插入点)</a>:
                      <ol>
                        <li>如果<var>INSERTION-POINT(插入点)</var>是一个<a>shadow insertion point(阴影插入点)</a>:
                          <ol>
                            <li>让<var>SHADOW-ROOT</var>作为<var>INSERTION-POINT(插入点)</var>的<a>root(根)</a> <a>node(节点)</a></li>
                            <li>如果<var>SHADOW-ROOT</var>不是最<a>oldest shadow root(外层的阴影根)</a>:
                              <ol>
                                <li>增加比此根<a>older shadow root(更外层的阴影根)</a>相对于<var>SHADOW-ROOT</var><var>PATH(路径)</var></li>
                              </ol></li>
                          </ol></li>
                        <li>增加<var>INSERTION-POINT(插入点)</var>到<var>PATH(路径中)</var></li>
                      </ol></li>
                    <li>让<var>CURRENT(当前的事件目标)</var>作为<var>CURRENT(当前的事件目标)</var>的<a>final destination(最终目标)</a></li>
                  </ol></li>
                <li>否则:
                  <ol>
                    <li>如果<var>CURRENT(当前事件目标)</var>是一个<a>shadow root</a>:
                      <ol>
                        <li>如果<var>NODE(节点)</var>和<var>CURRENT(当前事件的目标)</var>在同一个<a>node tree(节点树中)</a>并且<var>EVENT(事件)</var>是需要 <a title="events-always-stopped">被阻止的事件</a>:
                          <ol>
                            <li>停止使用此算法</li>
                          </ol></li>
                        <li>让<var>CURRENT(当前事件的目标)</var>成为<a>shadow host(阴影宿主)</a>,<a>承载</a><var>CURRENT(当前事件的目标)</var></li>
                        <li>增加<var>CURRENT(当前事件的目标)</var>到<var>PATH(路径中)</var></li>
                      </ol></li>
                    <li>否则:
                      <ol>
                        <li>让<var>CURRENT(当前的事件目标)</var>作为<var>CURRENT(当前事件的目标)</var>的<a>parent(父)</a> <a>node(节点)</a></li>
                        <li>如果<var>CURRENT(当前的事件目标)</var>存在:
                          <ol>
                            <li>增加<var>CURRENT(当前的事件目标)</var>到<var>PATH(路径)</var>中</li>
                          </ol></li>
                      </ol></li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

      </section>

      <section class="informative">
        <h3>事件路径的示例</h3>

        <p>
          假设我们现在下列一个树:
        </p>

        <figure>
          <object data="../../assets/images/event-path-tree-of-trees.svg" width="301" height="1074"></object>
          <figcaption>一个示例树. 树的节点并没有关联到事件路径的示例中, 我们下面会解释, 目前先忽略这些树的节点.</figcaption>
        </figure>

        <ul>
          <li>
            <code>A</code> is a <a>document(文档)</a>.
          </li>
          <li>
            <code>E</code>, <code>J</code>, <code>N</code>, <code>Q</code>, <code>S</code>和<code>V</code> 是 <a title="shadow root">shadow roots</a>.
          </li>
          <li>
            <code>I</code>, <code>M</code>, <code>P</code>, <code>R</code>和 <code>U</code> 是 <a title="content insertion point">content insertion points(内容的插入点)</a>.
          </li>
          <li>
            <code>X</code> 是一个 <a>shadow insertion point(阴影插入点)</a>.
          </li>
        </ul>

        <p>
          这颗<a>tree of trees(树)</a>拥有以下的7棵<a title="node tree">node trees(节点树)</a>, 一棵<a>document tree(文档树)</a>和 6棵 <a title="shadow tree">shadow trees</a>:
        </p>

        <ul>
          <li>
            <var>document tree(文档树) 1</var>. 节点<code>A</code>, <code>B</code>, <code>C</code> 和 <code>D</code>这些节点在文档树中.
          </li>
          <li>
            <var>shadow tree 2</var> 托管给了<code>B</code>. 节点<code>E</code>, <code>F</code>, <code>G</code>, <code>H</code>和<code>I</code>这些节点在阴影树2中.
          </li>
          <li>
            <var>shadow tree 3</var> 托管给了<code>H</code>. 节点 <code>J</code>, <code>K</code>, <code>L</code> 和 <code>M</code>这些节点在阴影树3中.
          </li>
          <li>
            <var>shadow tree 4</var> 托管给了<code>K</code>. 节点 <code>N</code>, <code>O</code> 和 <code>P</code> 这些节点在阴影树4中.
          </li>
          <li>
            <var>shadow tree 5</var> 托管给了<code>O</code>. 节点 <code>Q</code> 和 <code>R</code> 这些节点在阴影树5中.
          </li>
          <li>
            <var>shadow tree 6</var> 托管给了<code>F</code>. 节点 <code>S</code>, <code>T</code> 和 <code>U</code> 这些节点在阴影树6中.
          </li>
          <li>
            <var>shadow tree 7</var> 托管给了<code>B</code>. 节点 <code>V</code>, <code>W</code> 和 <code>X</code> 这些节点在阴影树7中.
            <a>shadow tree</a> 7是比<var>shadow tree 2</var>更早生成的.
          </li>
        </ul>

        <p>
          让我们假设这颗<a>tree of trees(树)</a>的 <a>分布结果</a>是:
        </p>

        <ul>
          <li>
            <code>C</code><a>destination insertion points(目标插入点)</a>是 <code>[I, M]</code> (<code>C</code>是被重新分布的)
          </li>
          <li>
            <code>L</code><a>destination insertion points(目标插入点)</a>是 <code>[P, R]</code> (<code>L</code>是被重新分布的)
          </li>
          <li>
            <code>G</code><a>destination insertion points(目标插入点)</a>是 <code>[U]</code>
          </li>
          <li>
            <code>F</code><a>destination insertion points(目标插入点)</a>是 <code>[X]</code>
          </li>
        </ul>

        <p>
          在这种情况下, 如果一个事件在被分发到<code>D</code>上, 这个事件路径是:
        </p>
        <p>
          <code>
            [D, C, I, M, L, P, R, Q, O, N, K, J, H, G, U, T, S, F, E, X, W, V, B, A]
          </code>
        </p>

        <p>
          记录<a>event path calculation algorithm(事件路径的算法)</a> 是被设计用来实现以下目标:
        </p>

        <ol>
          <li>
            如果这里有节点, <var>CHILD(子节点)</var>在事件路径中并且<var>CHILD(子节点)</var>拥有父节点, <var>PARENT(父节点)</var>在节点树中, 事件路径也应该包括 <var>PARENT(父节点)</var>.
            <var>PARENT(父节点)</var>在事件路径中通常出现在<var>CHILD(子节点)</var>之后.
          </li>
          <li>
            在每一个<a>node tree(节点树)</a>中节点的事件路径来自于一个<em>直系祖先</em>. 在每一个<a>node tree(节点树)</a>中是没有<em>branch points(分支点)</em>的.
          </li>
        </ol>

        <figure>
          <object data="../../assets/images/event-path-node-trees.svg" width="884" height="473">></object>
          <figcaption>
            一个事件路径和节点树的关系. 在图中, 在每个节点被展示出来的左分支代表在事件路径中每一个节点最初起始的位置.
            在一个节点树中,一个父节点通常有大量比自身子元素更多的事件路径的起始位置.
          </figcaption>
        </figure>

        <p>
          这意味着如果我们获取一个<a>node tree(节点树)</a>的焦点并且忽视掉其他所有的 <a title="node tree">node trees(节点树)</a>,
          事件路径将似乎看上就好像事件发生在我们所获取焦点的<a>node tree(节点树)</a>上.
          这是一个非常重要的方面从某种意义上来说进行托管的阴影树在<em>包含</em><a>node tree(节点树)</a><a>shadow host</a>其中的情况下对于事件路径不具有任何影响
          只要这个事件没有在<a title="descendant tree">descendant trees(子树)</a>上被阻止.
        </p>

        <p>
          举个例子, 通过<var>document tree(文档树) 1</var>的视图, 事件路径看上去将会是<code>[D, C, B, A]</code>.
          通过<var>shadow tree 2</var>的视图, 事件路径看上去将会是<code>[I, H, G, F, E]</code>.
          这种相似情况同样会应用于 <a title="node tree">node trees(节点树)</a>.
        </p>

        <p>
          这也是值得我们指出的一种情况如果我们从事件路径中排除全部<a title="insertion point">insertion points(插入点)</a>和<a title="shadow root">shadow roots</a>,
          这种结果等价于包括所有的祖先节点在生成树中分发事件.
        </p>

        <figure>
          <object data="../../assets/images/event-path-and-composed-tree.svg" width="217" height="1723"></object>
          <figcaption>
            一个事件路径和<a>composed tree(生成树)</a>的关系. 事件路径使用了此例子中在左分支上个被展示出的节点同时<a>composed tree(生成树)</a>展示了右分支的节点.
            如果我们从事件路上上排除所有<a title="insertion point">insertion points(插入点)</a>和<a title="shadow root">shadow roots</a>,
            这种情况等价于在<a>composed tree(生成树)</a>中包含所有有祖先的节点, <code>D</code>.
          </figcaption>
        </figure>

      </section>

      <section>
        <h3>事件的重定向</h3>

        <p>在事件路径穿过大多数节点树的情况下, 事件信息包括事件的目标是被调整过的为了维持<a href="#encapsulation">encapsulation(封装性)</a>. 事件<dfn>retargeting(重定向)</dfn>是一个当事件在每一个有祖先的<a>节点</a>上被分发时去计算相关联的目标. 一个<dfn>relative target(相关联的目标)</dfn>是一个<a>node(节点)</a>,此给定了父元素的节点能最准确代表当前被分发事件的目标当保持封装性的时.</p>

        <p><dfn>retargeting algorithm(重定向算法)</dfn>被用来决定相关联的元素, 它<strong>must(必须)</strong> <a title="processing equivalence">equivalent(等价)</a>于经过下列的步奏:</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>EVENT-PATH(事件路径)</var>, an event path(一个事件路径)</dd>
            <dd><var>CURRENT-TARGET(当前的目标)</var>, 在某个地方是被事件监听所关联的一个<a>node(节点)</a>.</dd>
            <dt>Output</dt>
            <dd><var>RELATIVE-TARGET(相关联的目标)</var>, 调整后的目标</dd>
          </dl>
          <ol>
            <li>让<var>CURRENT-TARGET-TREE(当前目标树)</var>成为<a>node tree(节点树)</a>,<var>CURRENT-TARGET(当前目标)</var>在<a>其中</a></li>
            <li>让<var>ORIGINAL-TARGET(源目标)</var>成为<var>EVENT-PATH(路径)</var>中的第一项</li>
            <li>让<var>ORIGINAL-TARGET-TREE(源目标树)</var>成为<a>node tree(节点树)</a>,<var>ORIGINAL-TARGET(源目标)</var>在<a>其中</a></li>
            <li>让<var>RELATIVE-TARGET-TREE(相关联的目标树)</var>最小(<var>CURRENT-TARGET-TREE(当前目标树)</var>和<var>ORIGINAL-TARGET-TREE(源目标树)</var>之间拥有共同的<a>inclusive ancestor tree(包括祖先的元素)</a></li>
            <li>让<var>RELATIVE-TARGET(相关联的目标)</var> 成为第一个在<var>EVENT-PATH(事件路径)</var>中<a>node(节点)</a>,此节点需要满足以下条件:
              <ol>
                <li>此<a>node(节点)</a>必须<a>在</a><var>RELATIVE-TARGET-TREE(相关联的树)</var>中</li>
              </ol>
            </li>
          </ol>
        </div>

        <p>重定向过程<strong>必须</strong>发送在一个事件被分发之前.</p>
      </section>

      <section>
        <h3>重定向的 <code>关系目标</code></h3>

        <p>一些事件有一个<a><code>relatedTarget(关联目标)</code></a> [[!DOM-Level-3-Events]]属性,  这个属性是一个不是事件目标的<a>node(节点)</a>, 但是和事件有关系.</p>

        <p>举个实例, 一个<code>mouseover</code>事件的<a><code>relatedTarget(关联目标)</code></a>可能拥有一个<a>node(节点)</a>来自于鼠标被移动到事件<code>target(目标)</code>.在<code>relatedTarget(相关联目标)</code>是一个<a>shadow tree</a>的情况下, 符合标准的UAs <strong>必须</strong>不能把真是的值泄露出这颗树. 在<code>relatedTarget(相关联目标)</code>和<code>target(目标)</code>都属于相同<a>shadow tree</a>的一部分, 符合标准的UAs <strong>必须</strong> <em>阻止</em>在阴影根上的事件去避免出现在<code>mouseover</code> 和 <code>mouseout</code>事件触发来自于于同一节点的错误.</p>

        <p>因此, 如果一个事件有 <code>relatedTarget(相关联目标)</code>, 它的值和事件分发的范围 <strong>必须</strong>被调整. 通常来说:</p>
        <ol>
          <li>对于给定的一个节点, <code>relatedTarget(相关联的目标)</code> <strong>必须</strong>改为它的祖先 (或者它本身) 作为一个节点在同一个<a>shadow tree</a>中</li>
          <li>事件监听<strong>一定不能够</strong>在一个<a>node(节点)</a>上被调用,此时节点的<code>target(目标)</code>和<code>relatedTarget(相关联的目标)</code>是相同的.</li>
        </ol>

        <p><dfn>related target resolution algorithm(相关联目标分辨算法)</dfn> <strong>必须</strong>必须用来决定<a><code>relatedTarget(相关联目标)</code></a>属性的值并且<strong>必须</strong><a title="processing equivalence">equivalent(等价)</a>于经过下列步骤的处理:</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>EVENT(事件)</var>, 一个事件</dd>
            <dd><var>CURRENT-TARGET(当前的目标)</var>, 一个被事件监听所调用的<a>node(节点)</a></dd>
            <dd><var>RELATED-TARGET(相关联的目标)</var>, 被事件所关联到的目标</dd>
            <dt>输出</dt>
            <dd><var>ADJUSTED-RELATED-TARGET(调整过的相关联的目标)</var>, 相对于<var>CURRENT-TARGET(当前目标)</var><dfn>adjusted related target(调整后的目标)</dfn></dd>
          </dl>
          <ol>
            <li>让<var>CURRENT-TARGET-TREE(当前目标树)</var>成为一个包含<var>CURRENT-TARGET(当前目标)</var>的<a>node tree(节点树)</a></li>
            <li>让<var>RELATED-TARGET-TREE(关联目标树)</var>成为一个包含<var>RELATED-TARGET(关联目标)</var>的<a>node tree(节点树)</a></li>
            <li>让<var>RELATED-TARGET-EVENT-PATH(相关目标事件路径)</var>在<var>RELATED-TARGET(关联目标)</var>和<var>EVENT(事件)</var>中通过<a>event path calculation algorithm(事件路径计算算法)</a>的结果输出</li>
            <li>如果<var>CURRENT-TARGET-TREE(当前目标树)</var>和<var>RELATED-TARGET-TREE(关联目标树)</var>都在同一个<a>tree of trees(树)</a>:
              <ol>
                <li>让<var>LOWEST-COMMON-ANCESTOR-TREE(共有度最高的祖先树)</var>成为<var>CURRENT-TARGET-TREE(当前目标树)</var>和<var>RELATED-TARGET-TREE(关联目标树)</var>中<a>inclusive ancestor tree(包含的祖先树)</a>中共有度最高的 </li>
              </ol>
            </li>
            <li>否则:
              <ol>
                <li>让<var>LOWEST-COMMON-ANCESTOR-TREE(共有度最高的祖先树)</var>成为<var>RELATED-TARGET-TREE(相关联目标树)</var>的<a>root tree(根树)</a></li>
              </ol>
            </li>
            <li>对于每一个<a>inclusive ancestor tree(包含祖先的树)</a>, <var>COMMON-ANCESTOR-TREE(共有祖先的树)</var>, <var>LOWEST-COMMON-ANCESTOR-TREE(共有度最高的祖先树)</var>, 在递增的顺序上:
              <ol>
                <li>让<var>ADJUSTED-RELATED-TARGET(调整后的相关的目标)</var>成为<var>RELATED-TARGET-EVENT-PATH(相关目标事件路径)</var>中的第一个<a>node(节点)</a>只要符合以下的条件:
                  <ol>
                    <li><a>node(节点)</a> <a>包含在</a><var>COMMON-ANCESTOR-TREE(共同的祖先树)</var>中</li>
                  </ol>
                </li>
                <li>如果<var>ADJUSTED-RELATED-TARGET(调整后的相关的目标)</var>存在:
                  <ol>
                    <li>停止使用此算法</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </div>

        <p class="note">相关目标分辨算法的返回结果不总为null. 如果发生这种情况, 你需要对本标准提出bug并反馈给我们.</p>

        <p>相关目标重定向的过程<strong>必须</strong>必须发生在一个事件分发之前.</p>
      </section>

      <section>
        <h3>重定向触摸事件</h3>

        <p><a><code>Touch(触摸)</code></a> <a title="Touch target"><code>target(目标)</code></a> [[!TOUCH-EVENTS]] 属性必须被调整就像一个<a><code>relatedTarget(相关目标)</code></a>的一个事件. 每一个<a><code>Touch(触摸)</code></a> <a title="Touch target"><code>target(目标)</code></a>在<a><code>TouchList(触摸列表)</code></a>的返回结果来自于<a><code>TouchEvent(触摸事件)</code></a>的<a title="touches"><code>touches()</code></a>, <a title="changedTouches"><code>changedTouches()</code></a> 和<a title="targetTouches"><code>targetTouches()</code></a>的结果一定是经过<a>related target resolution algorithm(相关目标解析算法)</a>, 指定一个<var>NODE(节点)</var>和<a><code>Touch(触摸)</code></a> <a title="Touch target"><code>target(目标)</code></a>作为参数.</p>
      </section>

      <section>
        <h3>重定向得到焦点事件</h3>

        <p><code>focus(得到焦点)</code>, <code>DOMFocusIn</code>, <code>blur(失去焦点)</code>, 和<code>DOMFocusOut</code> 事件 <strong>必须</strong>被认为是和带有<code>relatedTarget(相关)</code>的事件是同一种方式的, 符合的<a>node(节点)</a>的相关联的目标是在<a>target(目标)</a>得到焦点时又失去焦点时使用失去焦点时的结果或者 <a>node(节点)</a>获得焦点, 同时又造成它失去焦点<code>target(目标)</code> 行为的节点作为相关联的目标.</p>
      </section>

      <section>
        <h3>事件分发</h3>

        <p>在分发事件的时候:</p>
        <ul>
          <li><a><code>Event(事件)</code></a> <a><code>target(目标)</code></a> 和 <a><code>currentTarget(当前目标)</code></a>的属性 <strong>必须</strong>返回一个<a>relative target(相关联的目标)</a>给<a>node(节点)</a>当节点的事件监听<a title="event listener invoke">invoked(被触发)</a></li>
          <li><a><code>MouseEvent(鼠标事件)</code></a>的<a><code>relatedTarget(相关目标)</code></a> 属性 <strong>必须</strong>返回一个<a>调整后的相关目标</a></li>
          <li><a><code>MouseEvent(鼠标事件)</code></a>的<a><code>offsetX</code></a> 和 <a><code>offsetY</code></a> 属性 <strong>必须</strong> 返回一个相对定位于坐标系初始<a>padding edge(边距边缘)</a>的<a>relative target(相关元素)</a>的坐标</li>
          <li><a><code>Touch(触摸)</code></a> <a title="Touch target"><code>target(目标)</code></a> 属性 <strong>必须</strong> 返回一个 <a>调整后的相关目标</a></li>
          <li>如果<a><code>relatedTarget(相关目标)</code></a>和<a><code>target(目标)</code></a>都指向同一个节点, 节点本身的事件监听<strong>一定不能</strong>被调用. <a><code>TouchEvent(触摸事件)</code></a>在这个规则上没有问题.</li>
          <li>当<em>capturing(事件捕获)</em>, 事件捕获必须要有<a title="event dispatch">event dispatch algorithm(事件分发算法)</a>步骤6的过程, 事件监听<strong>一定不能</strong>在<a>relative target(相关目标)</a>是自己本身节点的时候被<a title="event listener invoke">调用</a></li>
          <li>当<em>bubbling(事件冒泡)</em>, 事件冒泡必须要有<a title="event dispatch">event dispatch algorithm(事件分发算法)</a>步骤9的过程, <a><code>Event(事件)</code></a> <a>eventPhase(解析)</a> 属性 <strong>必须</strong> 返回一个 <a>AT_TARGET</a> <strong>如果</strong>是<a>relative target(相关元素)</a> 同<a>node(节点)</a>一样当事件监听<a title="event listener invoke">被调用</a></li>
          <li>如果事件<a><code>bubbles(冒泡)</code></a>的属性值是<strong>false</strong>, 必须经过以下步骤:
            <ol>
              <li>将<em>event path(事件路径)</em>的顺序倒序</li>
              <li>初始化事件的<a><code>eventPhase(事件解析)</code></a> 属性<a><code>AT_TARGET</code></a></li>
              <li>对于<em>event path(事件路径中)</em>的每一个对象，当<a>relative target(关联目标)</a>和对象相同, <a title="event listener invoke">调用</a>它自身的<a title="event listener">event listeners(事件监听)</a>, 在事件<em>处理</em>时, 只要<em>event(事件)</em>的 <a>停止冒泡的</a>没有设置</li>
            </ol></li>
        </ul>

        <p>在事件分发完成之上, <a><code>Event(事件)</code></a>对象 <a><code>target(目标)</code></a>和<a><code>currentTarget(当前目标)</code></a> <strong>一定</strong> 必须应该是最顶层的祖先<a>relative target(相关目标)</a>. 只要一段script可能控制了<code>Event</code>对象在事件分发的范围内的传递, 这个步骤需要去避免暴露在<a title="shadow tree">shadow trees</a>上的 <a title="node">nodes(节点)</a>.</p>
      </section>

      <section class="informative">
        <h3>事件重定向的示例</h3>

        <p>假设我们现在有一个媒体控件的用户实例, 通过下列这个树来描述它, 由<a>document tree(文档树)</a>和<a title="shadow tree">shadow trees</a>两部分组成. 在这个例子中, 我们将假设选择器被允许穿过阴影的边界并且我们将使用这些选择器去定义找到这些<a title="element">elements(元素)</a>. 当然, 我们也将创建一个虚构的<code>shadow-root</code> <a>element(元素)</a> 去划分阴影边界并且 表现出 <a title="shadow root">shadow roots</a>:</p>
        <pre class="example">
&lt;div id=&quot;player&quot;&gt;
    <span class=shadow-boundary>&lt;shadow-root id=&quot;player-shadow-root&quot;&gt;</span>
        &lt;div id=&quot;controls&quot;&gt;
            &lt;button id=&quot;play-button&quot;&gt;PLAY&lt;/button&gt;
            &lt;input type=&quot;range&quot; id=&quot;timeline&quot;&gt;
                <span class=shadow-boundary>&lt;shadow-root id=&quot;timeline-shadow-root&quot;&gt;</span>
                    &lt;div id=&quot;slider-thumb&quot; id=&quot;timeline-slider-thumb&quot;&gt;&lt;/div&gt;
                <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
            &lt;/input&gt;
            &lt;div id=&quot;volume-slider-container&quot;&gt;
                &lt;input type=&quot;range&quot; id=&quot;volume-slider&quot;&gt;
                    <span class=shadow-boundary>&lt;shadow-root id=&quot;volume-shadow-root&quot;&gt;</span>
                        &lt;div id=&quot;slider-thumb&quot; id=&quot;volume-slider-thumb&quot;&gt;&lt;/div&gt;
                    <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
&lt;/div&gt;
        </pre>

        <p>让我们通过一个选择器the volume slider's thumb (<code>#volume-slider-thumb</code>)去指出控件的位置, 由此 在这个节点上去触发 一个<code>mouseover</code> 事件. 对于这个事件, 让我们假装认为没有<code>relatedTarget(相关联的目标)</code>.</p>

        <p>每一个<a>retargeting algorithm(重定向算法)</a>, 我们都需要设置以下的祖先和相关联的目标:</p>
        <table>
          <thead>
            <tr>
              <th>Ancestor</th>
              <th>Relative Target</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>#player</code></td>
              <td><code><strong>#player</strong></code></td>
            </tr>
            <tr>
              <td><code>#player-shadow-root</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#controls</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-container</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider</code></td>
              <td><code><strong>#volume-slider</strong></code></td>
            </tr>
            <tr>
              <td><code>#volume-shadow-root</code></td>
              <td><code>#volume-slider-thumb</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-thumb</code></td>
              <td><code><strong>#volume-slider-thumb</strong></code></td>
            </tr>
          </tbody>
        </table>

        <p>在我们分发 <code>mouseover</code>这个事件之后 使用 它们新计算出来的相关联目标, 用户决定去通过拇指去移动设备的时间线的位置
          (<code>#timeline-slider-thumb</code>). 这次触发有一次<code>mouseout</code>事件对于the volume slider thumb 和一次<code>mouseover</code> 事件 对于 the timeline thumb.</p>

        <p>让我们看看the volume thumb's的<code>relatedTarget(相关联目标)</code>的值是如何被  <code>mouseout</code>事件所影响的. 对于这次事件, <code>relatedTarget(相关联事件)</code>是the timeline thumb (<code>#timeline-slider-thumb</code>). 每一次的<a>related target resolution algorithm(关联目标解析算法)</a>, 我们都应该设置以下的祖先和调整关联的目标:</p>

        <table>
          <thead>
            <tr>
              <th>Ancestor</th>
              <th>Relative Target</th>
              <th>Adjusted related Target</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>#player</code></td>
              <td><code><strong>#player</strong></code></td>
              <td><code><strong>#player</strong></code></td>
            </tr>
            <tr>
              <td><code>#player-shadow-root</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#controls</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-container</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider</code></td>
              <td><code><strong>#volume-slider</strong></code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-shadow-root</code></td>
              <td><code>#volume-slider-thumb</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-thumb</code></td>
              <td><code><strong>#volume-slider-thumb</strong></code></td>
              <td><code><strong>#timeline</strong></code></td>
            </tr>
          </tbody>
        </table>

        <p>节点, <code>#player</code>, <code>target(目标)</code> 和 <code>relatedTarget(关联目标)</code> 同时都有相同的值 (<code>#player</code>), 这意味着它们并没有分发 <a>node(节点)</a>和它们的祖先上分发事件.</p>
      </section>
    </section>
    <section>
      <h2>用户交互</h2>

      <section class="informative">
        <h3>范围 和 选区</h3>

        <p>
          <a>选区</a> [[!EDITING]]([[!可编辑的区域]])是没有被定义的. 选区的开发和实现应该做到最好. 这是一个可能公认的错误的方法:
        </p>

        <p>由于<a title="node">nodes(节点)</a>在不同的<a title="node tree">node(节点)树上</a>绝对不可能拥有相同的<a>根(元素)</a>,它们可能绝对不会存在一个有效的<a title="range">DOM范围内</a>(这个DOM范围包含了多数的<a title="node tree">node(节点)树)</a>.</p>

        <p>因此<a title="selection">选区</a> 是可能存在于唯一一个 <a>node(节点)树</a>里, 因为选区被定义在一个单独的<a>范围里</a>. 通过方法<code><a>window.getSelection()</a></code>返回的<a>选区</a>绝对不会返回一个在<a>shadow树</a>里的<a>选区</a>.</p>

        <p><a>shadow根</a>对象的<code>getSelection()</code>方法返回的是当前<a>选区</a>是在当前(上下文)的<a>shadow tree</a>.</p>
      </section>

      <section>
        <h3>引导获取焦点</h3>

        <p>如果一个<a>节点</a>不<a title="participates">加入</a>一个<a>生成树(composed tree)</a>,  <a>此节点</a> <strong>必须</strong>从[[!CSS3UI]]<a>渲染树的顺序</a>中被忽略</p>

        <p>对于<a>引导获取焦点的时序</a>, <a>此引导顺序</a>的时序对于一个给定的<a>shadow tree</a> <var>A</var> <strong>必须</strong> 被插入到其他<a>node tree(节点树)</a> <a>引导顺序中</a> , 规则规则如下:</p>
        <ol>
          <li>如果<var>A</var>是<a>最新的shadow tree</a>:
            <ol>
              <li>让<var>宿主</var>成为<a>shadow host(阴影宿主)</a>,现在的阴影宿主就是<a>宿主</a>A</li>
              <li>让<var>B</var>成为<a>node tree(节点树)</a>,<var>让节点树的宿主</var>加入</li>
              <li>对于A的<a>引导顺序</a> <strong>必须</strong> 将A插入到<var>B</var> <a>的引导顺序</a>:
                <ol>
                  <li>立刻插入到<var>宿主</var>之后, 如果<var>宿主</var>是<a>可聚焦的</a>; 或者</li>
                  <li>取代<var>此宿主</var> ，如果 <var>此宿主</var> 被指定了属性 <a title="nav-index auto"><code>auto</code>这个属性</a>(auto这个属性决定了此宿主的位置)</li>
                </ol></li>
            </ol></li>
          <li>如果不是那么:
            <ol>
              <li>让<var>B</var>成为一个<a>优先级较高的shadow tree</a> , 让B关联到<var>A</var></li>
              <li>让<var>SHADOW</var>成为一个<a>shadow插入点</a>插入 <var>B</var>中</li>
              <li>如果<var>SHADOW</var> 存在, 在<var>SHADOW</var>之后,对于<var>A</var>的<a>引导顺序</a><strong>必须</strong>被插入到<var>B</var>的<a>引导顺序</a>  如果<var>SHADOW</var> 被指定了值 <a title="nav-index auto"><code>auto</code></a> 去决定它的位置.</li>
            </ol></li>
        </ol>

        <p>对于<a>有指向性的引导焦点</a>, 它取决于用户代理完整的  <a title="navigation order">引导顺序</a> 中 <a title="shadow tree">shadow trees</a> 在 <a>文本</a>中 <a>引导顺序</a>.</p>
      </section>

      <section>
        <h3>激活的元素</h3>

        <p>为了坚持封装性, <a>激活的元素</a>在<a title="Document object">文档</a>  对象的 focus(焦点) API 属性中的值 <strong>必须</strong>被调整的. 为了防止当调整这个值的时候丢失信息, 每一个 <a>shadow root(阴影的根)</a> <strong>必须</strong> 也拥有一个<code>激活元素的</code> 属性用来保存在<a>shadow tree</a>中获取焦点激活<a>元素的</a>属性值</p>

        <p>对于<dfn>激活 <a>元素</a> 的算法调整</dfn> 被用来决定<a>激活元素</a>的属性值,  激活元素<strong>必须</strong>经过如下列步骤一样的等价处理的过程:</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>元素</var>, 得到焦点的<a>元素</a></dd>
            <dd><var>ROOT(根)</var>, 要么是一个<a>文档</a> 或者是一个 <a>shadow root</a></dd>
            <dt>输出</dt>
            <dd><var>校正</var>, 一个已经被校正的<a>激活元素</a>属性的<var>根</var>.</dd>
          </dl>
          <ol>
            <li>让 <var>路径</var><var>元素和null</var>的<a>事件路径算法结果</a>作为输入</li>
            <li>让 <var>调整</var>过的<var>路径</var>和<var>根</var>的<a>重定向算法结果</a> 作为输出</li>
          </ol>
        </div>
      </section>

      <section>
        <h3>校订</h3>

        <p><a><code>contenteditable</code>属性的值</a><strong>一定不能通过<a>shadow host(阴影宿主)</a> </strong> 传播到它本身的 <a title="shadow tree">shadow trees</a>上.</p>
      </section>

      <section>
        <h3>辅助技术</h3>

        <p>用户代理可以通过辅助技术遍历<a>composed tree(生成树)</a>, 因此可以使完整的WAI-ARIA(可访问的富因特网应用程序) [[!WAI-ARIA]]语义在<a title="shadow tree">shadow trees</a>中使用.</p>

      </section>

    </section>

    <section>
      <h2>Shadow Trees中的HTML元素</h2>

      <p>相对来说, 一个<a>shadow tree</a>可以看作是存在于<em>部分<a>文档</a></em>和文档本身之间某处的一个<a title="interface DocumentFragment">文档碎片</a>. 当阴影树被渲染的时候, 单个<a>shadow tree</a> 目的是维持它本身在<a>文档</a>的传统<a>树</a>中的标准. 于此同时, 由于阴影树是抽象封装, 阴影树不能影响<a>文档树</a>. 因此, 阴影树中的<a>HTML元素</a> <strong>必须</strong> 表现为指定的 [[!HTML]]的行为在<a title="shadow tree">shadow trees</a>中, 除了少数例外的情况</p>

      <section>
        <h3>无效的HTML元素</h3>

        <p><a>HTML元素</a>一个子集合<strong>确定</strong> 行为表现为 <dfn>无效</dfn>, 或者不属于<a>document tree(文档树)</a>. 在这种一致的<a title="interface DocumentFragment">document fragment(文档碎片)</a>中的这种<a>HTML元素</a>如何表现. 这样 <a title="element">elements(元素)</a>有:</p>
        <ul>
          <li><a title="base element"><code>base</code></a></li>
          <li><a title="link element"><code>link</code></a></li>
        </ul>

        <p>剩下的其他<a>HTML元素</a>在<a title="shadow tree">shadow trees里</a> <strong>必须</strong> 表现为就像它们出现在<a>document tree(文档树)</a>中的表现.</p>
      </section>

    </section>

    <section>
      <h2>HTML元素和它们的shadow trees</h2>

      <p>每一个 <a title="HTML">规范</a>, 针对内容的渲染地方，一些<a>HTM元素</a>不是用来渲染它们的内容或针对特殊的需求所设计的. 是为了标准化HTML元素在<a>composed tree(生成树)</a>中渲染时的不同行为的,在<a>shadow tree</a>被创建和被填充进去的实例化<a>元素</a>的时候,所有的HTML元素<strong>必须</strong>具有<a title="processing equivalence">相同</a>的阴影树.这取决于用户代理定义阴影树.当然, 所有符合标准的用户代理<strong>必须</strong>满足以下的要求:</p>

      <table>
        <thead>
          <tr>
            <th style="width: 30%">HTML Element</th>
            <th>Shadow Tree Requirements</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><a title="img element"><code>img</code></a>, <a title="iframe element"><code>iframe</code></a>, <a title="embed element"><code>embed</code></a>, <a title="object element"><code>object</code></a>, <a title="video element"><code>video</code></a>, <a title="audio element"><code>audio</code></a>, <a title="canvas element"><code>canvas</code></a>, <a title="map element"><code>map</code></a>, <a title="input element"><code>input</code></a>, <a title="textarea element"><code>textarea</code></a>, <a title="progress element"><code>progress</code></a>, <a title="meter element"><code>meter</code></a></td>
            <td>如果这些<a>元素</a>可能有<a>回调的内容</a>, 包含一个<a>内容的插入点</a>. 这个(内容的插入点的)<a>匹配条件</a>的值<a>是一个通用的选择器</a>紧紧当这些<a>元素</a>需要展示<a>回调内容</a>时.其它方面, 包含没有<a title="content insertion point">内容插入点</a> 或者一个<a>内容插入点</a>什么都无法匹配.</td>
          </tr>
          <tr>
            <td><a title="fieldset element"><code>fieldset</code></a></td>
            <td>包含两个<a title="content insertion point">内容的插入点</a>要符合下列<a>匹配条件</a>:
              <ol>
                <li><code>legend:first-of-type</code></li>
                <li><a>universal selector(普通选择符)</a></li>
              </ol>
            </td>
          </tr>
          <tr>
            <td><a title="details element"><code>details</code></a></td>
            <td>包含两个<a title="content insertion point">内容的插入点</a>要符合下列<a>匹配条件</a>:
              <ol>
                <li><code>summary:first-of-type</code></li>
                <li><a>universal selector(普通选择符)</a></li>
              </ol>
            </td>
          </tr>
          <tr>
            <td>剩下所有<a title="element">elements(元素)</a></td>
            <td>包含一个<a>内容插入点</a>并且有<a>universal selector(普通选择符)</a>作为<a>匹配条件</a></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2>Elements(元素)和DOM Objects(DOM对象)</h2>

      <section>
        <h3><code>ShadowRoot</code>对象</h3>

        <p><code>ShadowRoot</code>对象代表此<a>shadow root</a>.</p>

        <dl class="idl" title="interface ShadowRoot : DocumentFragment">
          <dt>HTMLElement getElementById(DOMString elementId)</dt>
          <dd>
            <strong>必须</strong>行为完全就像<a>document.getElementById</a>一样, 除了<a title="scoping constraints">scoped(作用域)</a>范围是在此<a>shadow tree</a>内.
          </dd>

          <dt>NodeList getElementsByClassName(DOMString className)</dt>
          <dd>
            <strong>必须</strong>行为完全就像<a>document.getElementsByClassName</a>一样, 除了<a title="scoping constraints">scoped(作用域)</a>范围是在此<a>shadow tree</a>.
          </dd>

          <dt>NodeList getElementsByTagName(DOMString tagName)</dt>
          <dd>
            <strong>必须</strong>行为完全就像<a>document.getElementsByTagName</a>, 除了<a title="scoping constraints">scoped(作用域)</a>范围是在此<a>shadow tree</a>.
          </dd>

          <dt>NodeList getElementsByTagNameNS(DOMString? namespace, DOMString localName)</dt>
          <dd>
            <strong>必须</strong>行为完全就像<a>document.getElementsByTagNameNS</a>, 除了<a title="scoping constraints">scoped(作用域)</a>范围是在此<a>shadow tree</a>.
          </dd>

          <dt>Selection? getSelection()</dt>
          <dd>
            <p>返回当前在此<a>shadow tree</a>的区域</p>
            <p>当此方法被调用, 它<strong>必须</strong>返回此<a>shadow tree</a>的<a>selection(区域)</a>.</p>
          </dd>

          <dt>Element? elementFromPoint(double x, double y)</dt>
          <dd>
            <p>返回一个<a>element(元素)</a>指定的坐标系.</p>
            <p class="note">最终, 它需要是CSSOM View Module[[!CSSOM-VIEW]]标准的一部分</p>
            <p>
              当此方法被调用, 它<strong>必须</strong>返回下列步骤运行后的结果:
            </p>
            <ol>
              <li>如果<a>context object(上下文对象)</a>不是一个<a><code>ShadowRoot</code></a>的实例, 那么抛出一个<a><code>InvalidNodeTypeError(无效节点的错误)</code></a>错误.</li>
              <li>如果其中任意一个参数无效, <code>x</code>大于<a>viewport(视窗)</a>的宽度不包括已经被渲染出来的滚动条(如果有), 或者如果是<code>y</code>大于<a>viewport(视窗)</a>的高度不包括已经被渲染出来的滚动条(如果有), 返回<strong>null</strong>.</li>
              <li>让<var>HIT</var>这样的方式成为描述<a>element(元素)</a>在<a>viewport(视窗)</a>中<code>X</code>和<code>Y</code>坐标, 这样的方式决定于是否通过打点测试</li>
              <li>让<var>PATH(路径)</var>在<a>HIT</a>里通过<a>event path calculation algorithm(事件路径计算算法)</a>所得到的结果HRnull作为输入</li>
              <li>返回通过<a>retargeting algorithm(重定向算法)</a>所得到的结果<var>PATH(路径)</var>和<a>context object(上下文对象)</a>作为输入</li>
            </ol>
          </dd>

          <dt>只读 attribute Element? activeElement</dt>
          <dd>
            <p>表示当前在<a>shadow tree</a>得到焦点的<a>element(元素)</a></p>
            <p>当读取时, 这个属性<strong>必须</strong>返回在当前在<a>shadow tree</a>中得到焦点的<a>element(元素)</a>的属性或者为<code>null</code>, 如果这个属性不是空的.</p>
          </dd>

          <dt>只读 attribute Element host</dt>
          <dd>
            <p>表示此<a>shadow host(阴影宿主)</a>,此<a>hosts(宿主)</a>有此<a>context object(上下文对象)</a>.</p>
            <p>当读取时, 这个属性<strong>必须</strong>返回此<a>shadow host(宿主)</a>,这个<a>hosts(宿主)</a>有此<a>context object(上下文对象)</a>.</p>
          </dd>

          <dt>只读 attribute ShadowRoot? olderShadowRoot</dt>
          <dd>
            <p>表示此<a>older shadow root(不是最新的阴影根)</a>所关联到此<a>context object(上下文对象)</a></p>
            <p>
              当读取时, 此属性<strong>必须</strong>返回一个<a title="processing equivalence">equivalent(等价)</a>于下列步骤运行后的结果:
            </p>
            <ol>
              <li>如果此<a>context object(上下文对象)</a>是在<a>oldest shadow root(最原始的阴影根)</a>, 返回<strong>null</strong>.</li>
              <li>返回一个<a>older shadow root(不是最新的阴影根)</a>所关联到的<a>context object(上下文对象)</a>.</li>
            </ol>
            <p>对于<a>HTML elements(HTML元素)</a>, <a href="#html-elements-and-their-shadow-trees">UA-provided</a> <a title="shadow tree">shadow trees</a> <strong>一定是</strong>不能被使用的.</p>
          </dd>

          <dt>attribute DOMString innerHTML</dt>
          <dd>
            <p>表示<a><code>ShadowRoot</code></a>的标记上下文.</p>
            <p>当读取该属性时, 此属性<strong>必须</strong>返回在此<a>context object(上下文对象)</a>中通过<a>HTML fragment serialization algorithm(HTML文档序列化算法)</a>所处理过的结果作为 <a title="shadow host"><code>shadow host(阴影宿主)</code></a></p>
            <p>
              当设置该属性时,<strong>必须</strong>经过以下步骤:
            </p>
            <ol>
              <li>让<var>FRAGMENT(片段)</var>经过调用<a title="parse fragment">fragment parsing algorithm(片段解析算法)</a> [[!DOMPARSING]]使新设置的值作为<var>MARKUP(标识)</var>的结果, 并且此<a>context object(上下文对象)</a>作为<a title="shadow host"><code>shadow host(阴影宿主)</code></a></li>
              <li><a>Replace all(替换所有)</a>在<a>shadow root中的<var>FRAGMENT(片段)</var></a></li>
            </ol>
          </dd>

          <dt>只读 attribute StyleSheetList styleSheets</dt>
          <dd>
            <p>表示此<a>shadow root的样式列表</a>.</p>
            <p>当读取该属性事时, 此属性<strong>必须</strong>返回一个<a><code>StyleSheetList(样式表)</code></a>序列包含此<a>shadow root的样式表</a>.
            </p>
          </dd>
        </dl>

        <p>一个<a><code>ShadowRoot</code></a> 实例的 <a><code>nodeType(节点类型)</code></a>属性 <strong>必须</strong> 返回 <a><code>DOCUMENT_FRAGMENT_NODE</code></a>. 因此, 一个<a><code>ShadowRoot</code></a>实例的<a><code>nodeName(节点名)</code></a> 属性<strong>必须</strong>返回<code>"#document-fragment"</code>.</p>

        <p>调用方法<a><code>cloneNode()</code></a>方法去复制<a><code>ShadowRoot</code></a> 实例时 <strong>必须</strong>通常会抛出一个 <a><code>DATA_CLONE_ERR</code></a>异常.</p>

      </section>

      <section>
        <h3><code>Element(元素)</code>接口的扩展</h3>

        <dl class="idl" title="partial interface Element">
          <dt>ShadowRoot方法createShadowRoot()</dt>
          <dd>
            当此方法被调用, <strong>必须经过</strong>以下的步奏:
            <ol>
              <li>创建一个新的<a><code>ShadowRoot</code></a>对象实例</li>
              <li>增加此<a><code>ShadowRoot</code></a>对象到一个<a title="shadow roots list">有序的阴影根列表上</a>根关联上的此<a>context object(上下文对象)</a>作为最新的<a>shadow root</a></li>
              <li>返回一个<a><code>ShadowRoot</code></a>对象.</li>
            </ol>
          </dd>

          <dt>NodeList(节点列表) getDestinationInsertionPoints()</dt>
          <dd>当此方法被调用, 此方法<strong>必须</strong>返回一个<a>static(静态)</a>的<a><code>NodeList(节点列表)</code></a>由在<a>destination insertion points(目标插入点)</a>中的<a title="insertion point">插入点</a>的<a>context object(上下文对象)</a>所组成的.</dd>
            </dl>
      </section>

      <section>
        <h3>元素的<code>content(内容)</code></h3>

        <p>元素的<code><dfn title="content element">content(内容)</dfn></code>表示一个在<a>shadow tree</a>中的<a>insertion point(插入点)</a>.</p>

        <p>如果一个<code>content(内容)</code>元素不符合<a>insertion point(插入点)</a>的条件, </p>

        <dl>
          <dt>上下文</dt>
          <dd>预计<a>flow content(流内容)</a>.</dd>

          <dt>内容模块</dt>
          <dd><a>可见的</a></dd>

          <dt>内容的子元素</dt>
          <dd>一切可以作为回调的内容</dd>

          <dt>内容的属性</dt>
          <dd><a>全局属性</a></dd>
          <dd>
            <dl>
              <dt><code><dfn title="content element select">select(选择)</dfn></code>, 设置一个<a title="comma separated tokens">comma-separated tokens(对于逗号分割的标识)</a></dt>
              <dd>表示用于<a title="distribution">distributing(分发)</a><a>shadow host(宿主对象)</a>中的子<a title="node">nodes(节点)</a><a>matching criteria(匹配标准)</a>. 每一个标识<strong>必须</strong>是一个<a>compound selector(复合的选择器)</a>.</dd>
            </dl>
          </dd>

          <dt>DOM接口</dt>
          <dd>
            <dl class="idl" title="interface HTMLContentElement : HTMLElement">
              <dt>attribute DOMString select</dt>
              <dd><strong>必须</strong> <a>显示</a>此<a title="content element select">select(选择)</a>属性.</dd>

              <dt>NodeList getDistributedNodes()</dt>
              <dd>
                当此方法被调用, 它<strong>必须返回</strong>一个经过下列步骤的结果:
                <ol>
                  <li>
                    如果此<a>context object(上下文对象)</a>是一个<a>内容插入点</a>:
                    <ol>
                      <li>返回一个<a>静态</a>的<a><code>NodeList(节点列表)</code></a>由在<a>context object(上下文对象)</a>中<a>distributed nodes(分布的节点)</a>所组成的</li>
                    </ol>
                  </li>
                  <li>
                    其它情况:
                    <ol>
                      <li>返回一个空的<a>static(静态)</a> <a><code>NodeList(节点列表)</code></a>对象.</li>
                    </ol>
                  </li>
                </ol>
              </dd>
            </dl>
          </dd>
        </dl>
      </section>

      <section>
        <h3><code>shadow</code>元素</h3>

        <p><code><dfn title="shadow element">shadow</dfn></code>元素表示在<a>shadow tree</a>中的一个<a>shadow insertion point(阴影插入点)</a>.</p>
        <p>如果一个<code>shadow</code>元素不满足<a>insertion point(插入点)</a>的条件, 它<strong>必须</strong>就像<a><code>HTMLUnknownElement(未知HTML元素)</code></a>一样的渲染行为.</p>

        <dl>
          <dt>上下文</dt>
          <dd>预计的<a>流内容</a>.</dd>

          <dt>内容模块</dt>
          <dd><a>可见的</a></dd>

          <dt>阴影元素的子元素</dt>
          <dd>可以是一切</dd>

          <dt>DOM接口</dt>
          <dd>
            <dl class="idl" title="interface HTMLContentElement : HTMLElement">
              <dt>attribute DOMString select</dt>
              <dd><strong>必须</strong> <a>显示</a>此<a title="content element select">select(选择)</a>属性.</dd>

              <dt>NodeList getDistributedNodes()</dt>
              <dd>
                当此方法被调用, 它<strong>必须返回</strong>一个经过下列步骤的结果:
                <ol>
                  <li>
                    如果此<a>context object(上下文对象)</a>是一个<a>内容插入点</a>:
                    <ol>
                      <li>返回一个<a>静态</a>的<a><code>NodeList(节点列表)</code></a>由在<a>context object(上下文对象)</a>中<a>distributed nodes(分布的节点)</a>所组成的</li>
                    </ol>
                  </li>
                  <li>
                    其它情况:
                    <ol>
                      <li>返回一个空的<a>static(静态)</a> <a><code>NodeList(节点列表)</code></a>对象.</li>
                    </ol>
                  </li>
                </ol>
              </dd>
            </dl>
          </dd>
        </dl>
      </section>

      <section>
        <h3>异常的<code>Event(事件)的</code>接口</h3>

        <dl class="idl" title="partial interface Event">
          <dt>只读 attribute object path</dt>
          <dd>
            <p>表示此事件对象路径.</p>
            <p>
              当获取该属性时, 此属性<strong>必须</strong> 创建和返回一个新的JavaScript数组对象, 此数组对象从<a>context object(上下文对象)</a>的事件路径中拷贝而来.
            </p>
            <p class="issue">
              使用<code>Array(数组)</code> 作为在WebIDL中返回类型的<code>path(路径)</code>属性.
              WebIDL的bugs: <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20020"><code>Array</code>subclassing</a>
              和<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=23225"> class, not interface</a>.
            </p>
          </dd>
        </dl>
      </section>

    </section>

    <section>
      <h2>Shadow DOM示例</h2>

      <p>Bob被要求在把一个简单的链接列表变成一个消息控件,  消息控件能够连接到2个不同类别的新闻: 突发新闻和最新新闻. 目前新闻报道的文档组成看上去就像这样:</p>
      <pre class="example highlight">
&lt;ul class=&quot;stories&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/1&quot;&gt;A story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/2&quot;&gt;Another story&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;breaking&quot;&gt;&lt;a href=&quot;//example.com/stories/3&quot;&gt;Also a story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/4&quot;&gt;Yet another story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/4&quot;&gt;Awesome story&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;breaking&quot;&gt;&lt;a href=&quot;//example.com/stories/5&quot;&gt;Horrible story&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      </pre>

      <p>为了管理新闻报道, Bob决定使用<strong>shadow DOM</strong>. 这样做允许Bob保持整个标签的整洁, 拥有可以控制插入点的权会使得通过类名分类新闻的任务变的非常简单. 在得到一杯<a href="http://en.wikipedia.org/wiki/List_of_coffee_beverages#Green_Eye">Green Eye</a>后, 他制作出了如下shadow tree,<code>ul</code>元素成为了宿主:</p>
      <pre class="example highlight">
&lt;div class=&quot;breaking&quot;&gt;
    &lt;ul&gt;
        &lt;content select=&quot;.breaking&quot;&gt;&lt;/content&gt; &lt;!-- insertion point for breaking news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;other&quot;&gt;
    &lt;ul&gt;
        &lt;content&gt;&lt;/content&gt; &lt;!-- insertion point for the rest of the news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
      </pre>
      <p>Bob接下来根据来自于设计师的要求给新建立的消息控件样式，然后把它加入到shadow tree模型中:</p>
      <pre class="example highlight">
&lt;style&gt;
    div.breaking {
        color: Red;
        font-size: 20px;
        border: 1px dashed Purple;
    }
    div.other {
        padding: 2px 0 0 0;
        border: 1px solid Cyan;
    }
&lt;/style&gt;
      </pre>
      <p>他仔细考虑了下他的公司是否应该找一个新的设计师, Bob将模型转化成了代码:</p>
      <pre class="example highlight">
function createStoryGroup(className, contentSelector)
{
    var group = document.createElement('div');
    group.className = className;
    // Empty string in select attribute or absence thereof work the same, so no need for special handling.
    group.innerHTML = '&lt;ul&gt;&lt;content select=&quot;' + contentSelector + '&quot;&gt;&lt;/content&gt;&lt;/ul&gt;';
    return group;
}

function createStyle()
{
    var style = document.createElement('style');
    style.textContent = 'div.breaking { color: Red;font-size: 20px; border: 1px dashed Purple; }' +
        'div.other { padding: 2px 0 0 0; border: 1px solid Cyan; }';
    return style;
}

function makeShadowTree(storyList)
{
    var root = storyList.createShadowRoot();
    root.appendChild(createStyle());
    root.appendChild(createStoryGroup('breaking', '.breaking'));
    root.appendChild(createStoryGroup('other', ''));
}

document.addEventListener('DOMContentLoaded', function() {
    [].forEach.call(document.querySelectorAll('ul.stories'), makeShadowTree);
});
      </pre>

      <p>干得好, Bob! 在咖啡还有半杯的情况下, 工作完成了. 意识到自己很厉害, Bob将自己的经验通过<a href="http://en.wikipedia.org/wiki/Puyo_Puyo_(series)">Puyo Puyo</a>这样的方式传授给大家.</p>

      <p>几个月过去了.</p>

      <p>红旗飘飘了！ 在Bob一年一度的研讨会中, Alice 负责增加 <strong>另一个</strong>, 临时的盒子在新闻控件中, 其中有许多关于选举的新闻. Alice阅读学习了Bob's代码, 阅读了shadow DOM的标准并且实现了, 多亏shadow tree复合的支持, 她并没有修改Bob的代码. 就像平常一样, 她的解决方法优雅而简单, 适当的在Bob的代码上做了点巧妙的变化:</p>
      <pre class="example highlight">
// TODO(alice): BEGIN -- DELETE THIS CODE AFTER ELECTIONS ARE OVER.
var ELECTION_BOX_REMOVAL_DEADLINE = ...;

function createElectionStyle()
{
    var style = document.createElement('style');
    // TODO(alice): Check designer's desk for hallucinogens.
    style.textContent = 'div.election { color: Magenta; font-size: 24px; border: 2px dotted Fuchsia; }';
    return style;
}

function makeElectionShadowTree(storyList)
{
    var root = storyList.createShadowRoot();
    // Add and style election story box.
    root.appendChild(createElectionStyle());
    root.appendChild(createStoryGroup('election', '.election'));
    // Insert Bob's shadow tree under the election story box.
    root.appendChild(document.createElement('shadow'));
}

if (Date.now() &lt; ELECTION_BOX_REMOVAL_DEADLINE) {
    document.addEventListener('DOMContentLoaded', function() {
        [].forEach.call(document.querySelectorAll('ul.stories'), makeElectionShadowTree);
    });
}
// TODO(alice): END -- DELETE THIS CODE AFTER ELECTIONS ARE OVER.
      </pre>
      <p>使用<code>shadow</code> 元素允许Alice去组合Bob's组件<strong>到自己的组件里</strong>&mdash;在没有改变产品任何一行代码的情况下. 她对自己笑了, Alice意识到Bob已经想出一个方式关于保持文档标签整洁的想法, 但<strong>她</strong>是一个如此早的使用shadow tree组成这种很酷的方式去解决问题的人.</p>
    </section>

    <section class="appendix">
      <h2>致谢</h2>

      <p><span class="vcard">David Hyatt</span> 开发了 <a href="http://dev.w3.org/2006/xbl2/">XBL 1.0</a>, 并且和<span class="vcard">Ian Hickson</span>合写了<a href="http://dev.w3.org/2006/xbl2/">XBL 2.0</a>. 这两篇文档提供了极好的见解在函数闭包的问题并对本规范产生了巨大的影响.</p>

      <p><span class="vcard">Alex Russell</span>和他非常有远见的想法引发了在shadow Dom这个主题上引发了狂热的浪潮和如何在web中实际应用起来.</p>

      <p><span class="vcard">Dominic Cooney</span>, <span class="vcard">Hajime Morrita</span>, and <span class="vcard">Roland Steiner</span>不辞辛劳的工作在web平台范围里去解决函数闭包问题并且为这篇文档提供了稳固的基础.</p>

      <p>编者也感谢像<span class="vcard">Alex Komoroske</span>, <span class="vcard">Anne van Kesteren</span>, <span class="vcard">Brandon Payton</span>, <span class="vcard">Brian Kardell</span>, <span class="vcard">Darin Fisher</span>, <span class="vcard">Eric Bidelman</span>, <span class="vcard">Deepak Sherveghar</span>, <span class="vcard">Edward O'Connor</span>, <span class="vcard">Elisée Maurer</span>, <span class="vcard">Elliott Sprehn</span>, <span class="vcard">Erik Arvidsson</span>, <span class="vcard">Glenn Adams</span>, <span class="vcard">Jonas Sicking</span>, <span class="vcard">Malte Ubl</span>, <span class="vcard">Mike Taylor</span>, <span class="vcard">Oliver Nightingale</span>, <span class="vcard">Olli Pettay</span>, <span class="vcard">Rafael Weinstein</span>, <span class="vcard">Richard Bradshaw</span>, <span class="vcard">Ruud Steltenpool</span>, <span class="vcard">Sam Dutton</span>, <span class="vcard">Sergey G. Grekhov</span>, <span class="vcard">Shinya Kawanaka</span>, <span class="vcard">Tab Atkins</span>, <span class="vcard">Takashi Sakamoto</span>, and <span class="vcard">Yoshinori Sano</span>，感谢他们对此标准的意见和协助.</p>

      <p>此标准仍不完善. 还有许多工作需要做. 请通过阅读帮助我们并且记录bugs&mdash;千万不要忘记叫编者将你的名字添加到这里来.</p>
    </section>

  </body>
</html>
