<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'/>
    <title>Shadow DOM 中文规范</title>
    <script src='./autolink-config.js' class='remove'></script>
    <script src='../../assets/scripts/autolink.js' class='remove'></script>
    <link rel="stylesheet" href="../../assets/styles/respec-complement.css" type="text/css" />
    <script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "ED",
          shortName: "shadow-dom",
          editors: [{ name: "Dimitri Glazkov", url: "mailto:dglazkov@chromium.org", company: "Google, Inc." },
                    { name: "Hayato Ito", url: "mailto:hayato@google.com", company: "Google, Inc." }],
          wg: "W3C Web Applications (WebApps)",
          wgURI: "http://www.w3.org/2008/webapps/",
          wgPublicList: "public-webapps",
          wgPatentURI: "",
          edDraftURI: "http://w3c.github.io/webcomponents/spec/shadow/",
          otherLinks: [
              {
                  key: "Revision history",
                  href: "https://github.com/w3c/webcomponents/commits/gh-pages/spec/shadow/"
              }
          ],
          localBiblio: {
              "SELECTORS4": {
                  title: "Selectors Level 4",
                  href: "http://dev.w3.org/csswg/selectors4/",
                  authors: ["Elika Etemad", "Tab Atkins Jr"],
                  status: "ED"
              },
              "DOMPARSING": {
                  title: "DOM Parsing and Serialization",
                  href: "http://domparsing.spec.whatwg.org/",
                  authors:  ["Ms2ger"]
              },
              "EDITING": {
                  title: "HTML Editing APIs",
                  href: "https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html",
                  authors:  ["Aryeh Gregor"]
              }
          }
      };
      var bugAssistConfig = {
          blocked: '14978',
          short_desc: '[Shadow]: ',
          product: 'WebAppsWG',
          component: 'Component Model'
      };
    </script>
    <script src="../../assets/scripts/bug-assist.js" class="remove"></script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        这份规范描述了一种把多个 DOM 树结合进入一个层级结构中，并且这些树可以在同一份文档中交互的方法。这使得 DOM 结构能够更好的组合。
      </p>
    </section>

    <section id='sotd'>
    </section>

    <section>
      <h2>一致性</h2>

      <p>所有的图表、示例、注意事项，都和明示的非正式性章节一样是非正式性的。其余的部分都是正式性的。</p>

      <p>关键字“必须”、“禁止”、“要求”、“会”、“不会”、“应该”、“不应该”、“推荐”、“可以”和“可选的”等出现在文档的正式性部分中都应该遵循 [[!RFC2119]] 中的解释。但考虑到可读性，这些词汇在规范中并没有以大写形式出现。</p>

      <p>为了帮助分层，且避免在规范的不同部分之间产生循环依赖，该文档由三个连贯的叙述内容组成：</p>
      <ol>
        <li>搭建该规范的基础和背景，</li>
        <li>先解释概念模型和算法，然后</li>
        <li>通过 DOM 接口和 HTML 元素表达该模型。</li>
      </ol>

      <p>某种意义上说，这三个部分分别相当于是 <em>数学</em>——推理环境、<em>物理</em>——对概念的逻辑推理、和<em>机械</em>——对实践应用的推理。</p>

      <p>任何遵循该规范的用户代理必须根据概念模型决定的交互或状态，都会以<a href="http://en.wikipedia.org/wiki/Algorithm">算法</a>的方式进行捕获。该算法被定义为等价处理的术语。这里的<dfn>等价处理</dfn>是强制约束的算法实现，要求相同的输入通过用户代理实现和规范算法的输出是完全一致的。</p>
    </section>

    <section>
      <h2>概念</h2>

      <section class="informative">
        <h3>介绍</h3>

        <p>
          请移步至 <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a> 阅读这份非正式性介绍。
        </p>
      </section>

      <section>
        <h3>Shadow 树</h3>

        <p><dfn>文档树</dfn>是指<a>根</a><a>结点</a>是<a>文档</a>的<a>结点树</a> [[!DOM]]。</p>

        <p>任何元素都可以有一个包含 0 个或更多的<a title="node tree">结点树</a>的<dfn title="shadow roots list">关联有序列表</dfn>。</p>

        <p>如果一个<a>结点树</a>是一个元素的关联列表的成员，则称该元素<dfn>宿主</dfn>该<a>结点树</a>。</p>

        <p><dfn>Shadow 宿主</dfn>是指<a>宿主</a>一个或多个<a title="node tree">结点树</a>的元素。</p>

        <p><dfn>Shadow 树</dfn>是指被 <a>shadow 宿主</a><a title="hosts">宿主</a>的<a>结点树</a>。</p>

        <p><dfn>Shadow 根</dfn>是指 shadow 树的<a>根</a><a>结点</a>。</p>

        <p>如果超过一个 <a>shadow 树</a>被<a title="hosts">宿主</a>于相同的 <a>shadow 宿主</a>，则最近添加的 <a>shadow 树</a>被称为<dfn>更年轻的 shadow 树</dfn>同时最早添加的 <a>shadow 树</a>被称为<dfn>更老的 shadow 树</dfn>。</p>

        <p>如果没有比给定的 <a>shadow 树</a><a>更老的 shadow 树</a>，则该 <a>shadow 树</a>被称为<dfn>最老的 shadow 树</dfn>。</p>

        <p>如果没有比给定的 <a>shadow 树</a><a>更年轻的 shadow 树</a>，则该 <a>shadow 树</a>被称为<dfn>最年轻的 shadow 树</dfn>。</p>

        <p><dfn>更老的 shadow 根</dfn>是指<a>更老的 shadow 树</a>的根结点。</p>

        <p><dfn>更年轻的 shadow 根</dfn>是指<a>更年轻的 shadow 树</a>的根结点。</p>

        <p><dfn>最老的 shadow 根</dfn>是指<a>最老的 shadow 树</a>的根结点。</p>

        <p><dfn>最年轻的 shadow 根</dfn>是指<a>最年轻的 shadow 树</a>的根结点。</p>

        <p class="note">
          方便起见，<a>shadow 根</a>提供了其自己的<a title="DOM tree accessors">DOM 树存取器</a>方法集合。除了 <a>shadow 根</a>的后代，没有<a title="node">结点</a>可以访问这些方法。
        </p>
      </section>

      <section>
        <h3>树中树</h3>

        <p><dfn>树中树</dfn>是指包含<a title="node tree">结点树</a>的<a>树</a>。</p>

        <p class="note">
          这里引入树中树的目的在于方便下面章节中的算法定义。
        </p>

        <p>像<a>结点树</a>被定义为<a title="node">结点</a>之间的<a title="tree">一套关系集合</a>一样，<a>树中树</a>同样定义了<a title="node tree">结点树</a>之间的一套关系集合：</p>
        <ul>
          <li>
            如果下面两种条件之一被满足，<a>结点树</a> <var>A</var> 被称为<a>结点树</a> <var>B</var> 的一个<dfn>父级树</dfn>：
            <ul>
              <li><var>A</var> 和 <var>B</var> 在相同的<a title="shadow roots list">关联有序列表</a>中彼此相邻且 <var>A</var> 是相对于 <var>B</var><a>更老的 shadow 树</a>。</li>
              <li><var>B</var> 是<a>最老的 shadow 树</a>并且 <var>B</var> 的 <a>shadow 宿主</a>参与在 <var>A</var> 之中。</li>
            </ul>

          </li>
          <li>如果有超过一个<a>结点树</a>共享相同的<a>父级树</a>，则它们在<a>树中树</a>里的<a>树顺序</a>以如下方式定义：
            <ol>
              <li>让 <var>A</var> 和 <var>B</var> 成为共享同一个<a>父级树</a>的<a title="node tree">结点树</a>。</li>
              <li>如果下面两个条件之一被满足，则 <var>A</var> 在 <var>B</var> 之前：
                <ul>
                  <li><var>A</var> 的 <a>shadow 宿主</a><a>先于</a> <var>B</var> 的 <a>shadow 宿主</a>。</li>
                  <li><var>B</var> 不是<a>最老的 shadow 树</a>。</li>
                </ul>
              </li>
            </ol>
          </li>
          <li>其它关系和属于，比如<dfn>树根</dfn>、<dfn>子树</dfn>、<dfn>后代树</dfn>、<dfn>包含的后代树</dfn>、<dfn>祖先树</dfn>、<dfn>包含的祖先树</dfn>、<dfn>前面的树</dfn>同理于<a title="tree">树</a>的定义。</li>
        </ul>

        <p>一个 shadow 树的<a>结点</a>的 <a><code>ownerDocument</code></a> 属性<strong>必须</strong>引用该 shadow 树<a>的 shadow 宿主</a>的<a>文档</a>。</p>

        <p><a><code>Window</code></a> 对象中<a title="named access on the window object">被命名的属性</a> [[!HTML]] <strong>必须</strong> 访问该<a>文档树</a>中的<a title="node">结点</a>。</p>

        <section class="informative">
          <h3>树中树的例子</h3>

          <figure>
            <object data="../../assets/images/tree-of-trees.svg" width="650" height="823"></object>
            <figcaption>
              一个树中树
            </figcaption>
          </figure>

          <p>
            如图，这里有七个结点树，分别命名为 A、B、C、D、E 和 F。
            结点树 C、D 和 E 被宿主在同一个参与在结点树 A 上的 <a>shadow 宿主</a>。
            结点树 C 是<a>最老的 shadow 树</a>。结点树 E 是<a>最年轻的 shadow 树</a>。
            改图还存在下列关系：
            <ul>
              <li>A 的<a title="child tree">子树</a>的有序列表是 [B, C]。</li>
              <li>B 的<a title="child tree">子树</a>的有序列表是 []。</li>
              <li>C 的<a title="child tree">子树</a>的有序列表是 [F, D]。</li>
              <li>D 的<a title="child tree">子树</a>的有序列表是 [E]。</li>
              <li>E 的<a title="child tree">子树</a>的有序列表是 []。</li>
            </ul>
          </p>
        </section>

      </section>

      <section>
        <h3>组合树</h3>

        <p><dfn>组合树</dfn>是指由<a>树中树</a>里的多个<a title="node tree">结点树</a>作为<a title="node">结点</a>架构而成的一个<a>结点树</a>。详细的组合树结构算法会稍后被规范。</p>

        <figure>
          <object data="../../assets/images/composed-tree.svg" width="654" height="606"></object>
          <figcaption>一个组合树</figcaption>
        </figure>

        <p>在<dfn>渲染</dfn>一个<a>文档树</a>，或对其进行可视化展示时，<a>组合树</a><strong>必须</strong>被替换作<a>文档树</a>。</p>

        <p><a>组合树</a><strong>必须</strong>在<a>渲染</a>发生之前被更新。</p>
      </section>

    </section>

    <section>
      <h2>分布</h2>

      <section>
        <h3>插入点</h3>

        <p><dfn>插入点</dfn>是指一个被定义好的位置，当构造一个<a>组合树</a>的时候，别的<a>结点树</a>里的<a title="node">结点</a>可以替换出现在这个结点的位置。</p>

        <figure>
          <object data="../../assets/images/distributions.svg" width="663" height="598"></object>
          <figcaption>一个分布</figcaption>
        </figure>

        <p><dfn>分布</dfn>是决定哪个<a title="node">结点</a>出现在各个<a>插入点</a>的机制。<a>分布</a>的详细算法规范会在稍后看到。</p>
      </section>


      <section>
        <h3>内容插入点</h3>

        <p><dfn>内容插入点</dfn>是 <a>shadow 宿主</a>分布子<a title="node">结点</a>的<a>插入点</a>。满足下列所有条件的<a>内容元素</a>就相当于一个<a>内容插入点</a>：</p>
        <ul>
          <li>其<a>内容元素</a>的<a>根</a><a>结点</a>是一个 <a>shadow 根</a></li>
          <li>该<a>内容元素</a>的<a title="ancestor">祖先</a>里没有别的<a>内容元素</a></li>
          <li>该<a>内容元素</a>的<a title="ancestor">祖先</a>里没有 <a>shadow 元素</a></li>
        </ul>
      </section>

      <section>
        <h3>Shadow 插入点</h3>

        <p><dfn>Shadow 插入点</dfn>是会发布<a>更老的 shadow 根</a>的子节点<a>插入点</a>。满足下列所有条件的 <a>shadow 元素</a>就相当于一个 <a>shadow 插入点</a>：</p>
        <ul>
          <li>其 <a>shadow 元素</a>的<a>根</a><a>结点</a>是一个 <a>shadow 根</a></li>
          <li>没有<a>先于</a>该 <a>shadow 元素</a>的 <a>shadow 元素</a></li>
          <li>该 <a>shadow 元素</a>的<a title="ancestor">祖先</a>里没有别的<a>内容元素</a></li>
        </ul>
      </section>

      <section>
        <h3>分布结果</h3>

        <p>每个<a>树中树</a>都有<dfn>分布结果</dfn>。<a>分布结果</a><strong>必须</strong>与下列描述<a title="processing equivalence">等价</a>：</p>
        <ol>
          <li>每个<a>插入点</a>有一个被称作<dfn>已分布结点</dfn>的有序列表，该列表由分布在该<a>插入点</a>的<a title="node">结点</a>组成。</li>
          <li>每个非<a>插入点</a>的<a>结点</a>有一个被称作<dfn>目的插入点</dfn>的有序列表，该列表由分布该<a>结点</a>的<a title="insertion point">插入点</a>组成。</li>
        </ol>

        <p>如果<a>插入点</a> <var>A</var> 是<a>结点</a> <var>B</var> 的<a>目的插入点</a>，则 <var>A</var> 是 <var>B</var> 的<dfn>最终目的</dfn>。</p>

        <p>当<a>结点</a> <var>A</var> 被<dfn title="distributes">分布</dfn>到<a>插入点</a> <var>B</var> 时，<strong>必然</strong>发生下列步骤：</p>
        <ul>
          <li>把 <var>A</var> 添加到 <var>B</var> 的<a>已分布结点</a>中</li>
          <li>把 <var>B</var> 添加到 <var>A</var> 的<a>目的插入点</a>中</li>
        </ul>

        <div class="note">
          <p>当一个<a>插入点</a>是另一个 <a>shadow 宿主</a>的子<a>结点</a>时，需要特殊考虑。<a title="distributes">分布</a>到其<a>插入点</a>的<a title="node">结点</a>会出现并相当于它们是<a>分布</a>上下文的 <a>shadow 宿主</a>的子<a title="node">结点</a>。因此<a title="distributes">分布</a>到 <a>shadow 树</a>的<a title="node">结点</a>可能已被<a title="distributes">分布</a>自其父级树。</p>

          <p>一个结点尽管被分布到了不止一个插入点，其在最终目的的组合树中只会出现一个。</p>
        </div>

        <figure>
          <object data="../../assets/images/re-distributions.svg" width="693" height="822"></object>
          <figcaption>一个重分布。在该图中，一个结点 <em>child 1</em> 被分布进了 <em>insertion point 1</em>。然后 <em>child1</em> 被重分布进了 <em>insertion point 3</em>。<em>Child 1</em> 的目的插入点是 [<em>insertion point 1</em>, <em>insertion point 3</em>] 同时 <em>insertion point 3</em> 是 <em>child 1</em>的最终目的。<em>Insertion point 1</em> 和 <em>insertion point 3</em> 的被分布结点分别是 [<em>child 1</em>] 和 [<em>child 1</em>, <em>child 3</em>]。
          </figcaption>
        </figure>

      </section>

      <section>
        <h3>分布算法</h3>

        <p><dfn>分布算法</dfn><strong>必须</strong>用来判定一个<a>树中树</a>的<a>分布结果</a>且<strong>必须</strong><a title="processing equivalence">等价</a>于以下处理步骤：</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>TREE-OF-TREES</var>，一个<a>树中树</a></dd>
            <dt>输出</dt>
            <dd><var>TREE-OF-TREES</var> 的<a>分布结果</a>被更新</dd>
          </dl>
          <ol>
            <li>将所有归属于 <var>TREE-OF-TREES</var> 中<a title="node">结点</a>的<a>分布结点</a>和<a>目的插入点</a>设为空</li>
            <li>设 <var>ROOT-TREE</var> 为 <var>TREE-OF-TREES</var> 的<a>根树</a></li>
            <li>将 <var>ROOT-TREE</var> 作为输入，执行<a>分布决议算法</a></li>
          </ol>
        </div>

        <p><dfn>分布决议算法</dfn><strong>必须</strong>用来判定一个给定的<a>结点树</a>及其<a title="descendant tree">后代树</a>的<a>分布结果</a>，且<strong>必须</strong><a title="processing equivalence">等价</a>于以下处理步骤：</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>NODE-TREE</var>，一个<a>结点树</a></dd>
            <dt>输出</dt>
            <dd><var>NODE-TREE</var> 的<a title="inclusive descendant tree">包含的后代树</a>的<a>分布结果</a>会被更新</dd>
          </dl>

          <ol>
            <li>把每个参与 <var>NODE-TREE</var> 其中的 <a>shadow 宿主</a>定为 <var>SHADOW-HOST</var>，以<a>树顺序</a>：
              <ol>
                <li>将 <var>SHADOW-HOST</var> 作为输入执行<a>池占据算法</a>的结果设为 <var>POOL</var></li>
                <li>把每个 <var>SHADOW-HOST</var> <a>宿主</a>的 <a>shadow 树</a>定为 <var>SHADOW-TREE</var>，按照从<a>最年轻 shadow 树</a>到<a>最老 shadow 树</a>的顺序：
                  <ol>
                    <li>将 <var>SHADOW-TREE</var> 和 <var>POOL</var> 作为输入执行<a>池分布算法</a></li>
                  </ol></li>
                <li>把每个 <var>SHADOW-HOST</var> <a>宿主</a>的 <a>shadow 树</a>定为 <var>SHADOW-TREE</var>，按照从<a>最老 shadow 树</a>到<a>最年轻 shadow 树</a>的顺序：
                  <ol>
                    <li>把参与到 <var>SHADOW-TREE</var> 中的 <a>shadow 插入点</a>设为 <var>SHADOW</var></li>
                    <li>如果存在这样的 <var>SHADOW</var>：
                      <ol>
                        <li>如果 <var>SHADOW-TREE</var> 不是<a>最老的 shadow 树</a>：
                          <ol>
                            <li>将相对于 <var>SHADOW-TREE</var> <a>更老的 shadow 数</a>的根节点作为输入执行<a>池占据算法</a>的结果设为<var>POOL</var></li>
                          </ol></li>
                        <li>把每个 <var>POOL</var> 中的<a>结点</a>定为 <var>CHILD</var>
                          <ol>
                            <li>把 <var>CHILD</var> <a title="distributes">分布</a>到 <var>SHADOW</var> 中</li>
                          </ol></li>
                      </ol></li>
                    <li>将 <var>SHADOW-TREE</var> 作为输入递归执行<a>分布决议算法</a></li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p><dfn>池占据算法</dfn><strong>必须</strong>用来占据一个给定<a title="node">结点</a>的子<a title="node">结点</a>，且<strong>必须</strong>且<strong>必须</strong><a title="processing equivalence">等价</a>于以下处理步骤：</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>NODE</var>，一个结点</dd>
            <dt>输出</dt>
            <dd><var>POOL</var>，一个有序的结点列表</dd>
          </dl>

          <ol>
            <li>将 <var>POOL</var> 设为一个空的有序列表。</li>
            <li>把 <var>CHILD</var> 的每个<a>结点</a>定为 <var>NODE</var>：
              <ol>
                <li>如果 <var>CHILD</var> 是一个<a>插入点</a>：
                  <ol>
                    <li>把所有 <var>CHILD</var> 的<a>已分布结点</a>中的<a title="node">结点</a>添加到 <var>POOL</var> 中</li>
                  </ol></li>
                <li>否则：
                  <ol>
                    <li>把 <var>CHILD</var> 添加到 <var>POOL</var> 中</li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p><dfn>池分布算法</dfn><strong>必须</strong>用来把一个池中的<a title="node">结点</a>分布到其 <a>shadow 树</a>中的<a title="content insertion point">内容插入点</a>中，且<strong>必须</strong><a title="processing equivalence">等价</a>于以下处理步骤：</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>SHADOW-TREE</var>，一个 shadow 树</dd>
            <dd><var>POOL</var>，一个有序结点列表</dd>
            <dt>输出</dt>
            <dd>POOL 中的结点被分布到了该树中的内容插入点中。</dd>
          </dl>

          <ol>
            <li>把每个参与到 <var>SHADOW-TREE</var> 中的<a>内容插入点</a>定为 <var>CONTENT</var>，并按照树顺序：
              <ol>
                <li>把每个 <var>POOL</var> 里的<a>结点</a>定为<var>NODE</var>
                  <ol>
                    <li>如果 <var>NODE</var> 满足 <var>CONTENT</var> 的批评标准：
                      <ol>
                        <li>把 <var>NODE</var> <a title="distributes">分布</a>到 <var>CONTENT</var> 中</li>
                        <li>从 <var>POOL</var> 中移除 <var>NODE</var></li>
                      </ol></li>
                  </ol></li>
                <li>如果没有分布到 <var>CONTENT</var> 中的<a title="node">结点</a>：
                  <ol>
                    <li>把每个 <var>CONTENT</var> 的子节点定为 <var>CHILD</var>
                      <ol>
                        <li>把 <var>CHILD</var> <a title="distributes">分布</a>到 <var>CONTENT</var> 中</li>
                      </ol></li>
                  </ol></li>
              </ol></li>
          </ol>

        </div>

        <p class="note">如果没有结点被分布到一个<a>内容插入点</a> <var>CONTENT</var> 中，则 <var>CONTENT</var> 的子<a title="node">结点</a>会被分布到 <var>CONTENT</var> 中作为后备结点。</p>

        <p>如果影响<a>分布结果</a>的任何条件发生改变，则<a>分布结果</a><strong>必须</strong>先于任何对<a>分布结果</a>的使用被更新。</p>

      </section>

      <section>
        <h3>满足匹配标准</h3>

        <p>一个<a>插入点</a>的<dfn>匹配标准</dfn>是一个<a title="compound selector">复合选择器</a> [[!SELECTORS4]] 的集合。这些<a title="compound selector">复合选择器</a>被约束在了只包含这些<a title="simple selector">单一选择器</a>的范围内：</p>

        <ul>
          <li>一个<a>类型选择器</a>或<a>通用选择器</a></li>
          <li><a title="class selector">类选择器</a></li>
          <li>一个 <a>ID 选择器</a></li>
          <li><a title="attribute selector">特性选择器</a></li>
          <li>一个<a>否定的伪类</a> <code>:not()</code></li>
        </ul>

        <p>一个<a>结点</a>仅在下面的情形下<dfn title="satisfies-matching-criteria">满足</dfn>其<a>匹配规则</a>：</p>
        <ol>
          <li>所有集合中的<a title="compound selector">复合选择器</a>都只包含上述的<a title="simple selector">单一选择器</a>；且</li>
          <li>该<a>结点</a>至少匹配一个集合中的<a title="compound selector">复合选择器</a>或集合为空。</li>
        </ol>
      </section>

    </section>

    <section>
      <h2>组合</h2>

      <p><dfn>组合树子节点算法</dfn><strong>必须</strong>用来判定一个<a>组合树</a>中<a>结点</a>的子<a title="node">结点</a>，且<strong>必须</strong><a title="processing equivalence">等价</a>于以下处理步骤：</p>

      <div class="algorithm">
        <dl>
          <dt>输入</dt>
          <dd><var>NODE</var>，一个参与到组合树中的<a>结点</a></dd>
          <dt>输出</dt>
          <dd><var>CHILDREN</var>，其<a>组合树</a>中的 <var>NODE</var> 的子节点。</dd>
        </dl>

        <ol>
          <li>把 <var>CHILDREN</var> 设为空的有序结点列表</li>
          <li>如果 <var>NODE</var> 是一个 <a>shadow 宿主</a>：
            <ol>
              <li>把 <var>CHILD-POOL</var> 设为 <var>NODE</var> <a>宿主</a>的<a>最年轻 shadow 根</a>的子节点。</li>
            </ol></li>
          <li>否则：
            <ol>
              <li>把 <var>CHILD-POOL</var> 设为 NODE 的子<a title="node">结点</a></li>
            </ol></li>
          <li>对每个 <var>CHILD-POOL</var> 中的<a>结点</a> <var>CHILD</var>：
            <ol>
              <li>如果 <var>CHILD</var> 是一个<a>插入点</a>：
                <ol>
                  <li>对其<a>插入点</a> <var>CHILD</var> 的<a>分布结点</a>中的每个<a>结点</a> <var>DISTRIBUTED-NODE</var>:
                    <ol>
                      <li>如果 <var>CHILD</var> 是 <var>DISTRIBUTED-NODE</var> 的<a>最终目的</a>，则把 <var>DISTRIBUTED-NODE</var> 添加到 <var>CHILDREN</var> 中</li>
                    </ol></li>
                </ol></li>
              <li>否则：
                <ol>
                  <li>把 <var>CHILD</var> 添加到 <var>CHILDREN</var> 中</li>
                </ol></li>
            </ol></li>
        </ol>

      </div>

      <p>对一个给定的<a>树中树</a> <var>TREE-OF-TREES</var> 来说，由 <var>TREE-OF-TREES</var> 构造出的<a>组合树</a><strong>必须</strong><a title="processing equivalence">等价</a>于以下处理步骤：</p>
      <ul>
        <li><a>组合树</a>的<a>根</a><a>结点</a>是 <var>TREE-OF-TREES</var> 的<a>树根</a>的<a>根</a><a>结点</a>。</li>
        <li>对于一个<a>参与</a>到<a>组合树</a>中的给定的<a>结点</a>，其子<a title="node">结点</a>是将该<a>结点</a>作为输入执行<a>组合树子节点算法</a>的结果。
        </li>
      </ul>
    </section>

    <section>
      <h2>事件</h2>

      <p>当一个<a>Event(事件)在<a>shadow tree(阴影树)</a>中</a>被<a title="event dispatch">dispatched(分发)</a>时, 事件的路径要么穿过<a title="shadow tree">shadow trees(阴影树)</a>要么在<a>shadow root(阴影根)</a>被终止. 其中一个例外情况就是<a title="mutation event">mutation events(突发事件)</a>. <a title="mutation event">mutation event types(突发事件)</a> <strong>一定</strong> 不能在<a>shadow tree(阴影树)</a>中被分发.</p>
    </section>
      <section>
        <h3>通常会被阻止的事件</h3>

        <p><dfn title="events-always-stopped">following events(以下事件)</dfn> <strong>一定</strong>是通常会在<a>node tree(节点树)</a>的<a>root(根)</a> <a>node(节点)</a>被阻止:</p>
        <ul>
          <li><code>abort</code></li>
          <li><code>error</code></li>
          <li><code>select</code></li>
          <li><code>change</code></li>
          <li><code>load</code></li>
          <li><code>reset</code></li>
          <li><code>resize</code></li>
          <li><code>scroll</code></li>
          <li><code>selectstart</code></li>
        </ul>
      </section>

      <section>
        <h3>事件路径</h3>

        <p><dfn>event path calculation algorithm(事件路径算法)</dfn>一定是被用来决定事件路径并且<strong>一定</strong>要通过下列步骤<a title="processing equivalence">(相当于以下的步骤的过程)</a>:</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>NODE(节点)</var>, 一个节点</dd>
            <dd><var>EVENT(事件)</var>, 一个事件</dd>
            <dt>输出</dt>
            <dd><var>PATH(路径)</var>, 一个事件的路径, 一个事件目标的顺序列表</dd>
          </dl>
          <ol>
            <li>让<var>PATH(路径)</var>成为一个暂时为空的节点列表(有顺序的)</li>
            <li>让<var>CURRENT(当前的事件目标)</var>作为<var>NODE(节点)</var></li>
            <li>增加<var>CURRENT(当前的事件目标)</var>的节点到<var>PATH(路径)</var>中</li>
            <li>如果存在<var>CURRENT(当前的事件目标)</var>则重复:
              <ol>
                <li>如果<var>CURRENT(当前)</var>的<a>目标插入点</a>不为空:
                  <ol>
                    <li>对于每一个<a>insertion point(插入点)</a>, <var>INSERTION-POINT(插入点)</var>, 在<var>CURRENT(当前的)</var><a>destination insertion points(目标插入点)</a>:
                      <ol>
                        <li>如果<var>INSERTION-POINT(插入点)</var>是一个<a>shadow insertion point(阴影插入点)</a>:
                          <ol>
                            <li>让<var>SHADOW-ROOT(阴影根)</var>作为<var>INSERTION-POINT(插入点)</var>的<a>root(根)</a> <a>node(节点)</a></li>
                            <li>如果<var>SHADOW-ROOT(阴影根)</var>不是最<a>oldest shadow root(外层的阴影根)</a>:
                              <ol>
                                <li>增加比此根<a>older shadow root(更外层的阴影根)</a>相对于<var>SHADOW-ROOT(阴影根)</var><var>PATH(路径)</var></li>
                              </ol></li>
                          </ol></li>
                        <li>增加<var>INSERTION-POINT(插入点)</var>到<var>PATH(路径中)</var></li>
                      </ol></li>
                    <li>让<var>CURRENT(当前的事件目标)</var>作为<var>CURRENT(当前的事件目标)</var>的<a>final destination(最终目标)</a></li>
                  </ol></li>
                <li>否则:
                  <ol>
                    <li>如果<var>CURRENT(当前事件目标)</var>是一个<a>shadow root(阴影根)</a>:
                      <ol>
                        <li>如果<var>NODE(节点)</var>和<var>CURRENT(当前事件的目标)</var>在同一个<a>node tree(节点树中)</a>并且<var>EVENT(事件)</var>是需要 <a title="events-always-stopped">被阻止的事件</a>:
                          <ol>
                            <li>停止使用此算法</li>
                          </ol></li>
                        <li>让<var>CURRENT(当前事件的目标)</var>成为<a>shadow host(阴影宿主)</a>,<a>承载</a><var>CURRENT(当前事件的目标)</var></li>
                        <li>增加<var>CURRENT(当前事件的目标)</var>到<var>PATH(路径中)</var></li>
                      </ol></li>
                    <li>否则:
                      <ol>
                        <li>让<var>CURRENT(当前的事件目标)</var>作为<var>CURRENT(当前事件的目标)</var>的<a>parent(父)</a> <a>node(节点)</a></li>
                        <li>如果<var>CURRENT(当前的事件目标)</var>存在:
                          <ol>
                            <li>增加<var>CURRENT(当前的事件目标)</var>到<var>PATH(路径)</var>中</li>
                          </ol></li>
                      </ol></li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

      </section>

      <section class="informative">
        <h3>事件路径的示例</h3>

        <p>
          假设我们现在下列一个树:
        </p>

        <figure>
          <object data="../../assets/images/event-path-tree-of-trees.svg" width="301" height="1074"></object>
          <figcaption>一个示例树. 树的节点并没有关联到事件路径的示例中, 我们下面会解释, 目前先忽略这些树的节点.</figcaption>
        </figure>

        <ul>
          <li>
            <code>A</code> is a <a>document(文档)</a>.
          </li>
          <li>
            <code>E</code>, <code>J</code>, <code>N</code>, <code>Q</code>, <code>S</code>和<code>V</code> 是 <a title="shadow root">shadow roots(阴影根)</a>.
          </li>
          <li>
            <code>I</code>, <code>M</code>, <code>P</code>, <code>R</code>和 <code>U</code> 是 <a title="content insertion point">content insertion points(内容的插入点)</a>.
          </li>
          <li>
            <code>X</code> 是一个 <a>shadow insertion point(阴影插入点)</a>.
          </li>
        </ul>

        <p>
          这颗<a>tree of trees(树)</a>拥有以下的7棵<a title="node tree">node trees(节点树)</a>, 一棵<a>document tree(文档树)</a>和 6棵 <a title="shadow tree">shadow trees(阴影树)</a>:
        </p>

        <ul>
          <li>
            <var>document tree(文档树) 1</var>. 节点<code>A</code>, <code>B</code>, <code>C</code> 和 <code>D</code>这些节点在文档树中.
          </li>
          <li>
            <var>shadow tree(阴影树) 2</var> 托管给了<code>B</code>. 节点<code>E</code>, <code>F</code>, <code>G</code>, <code>H</code>和<code>I</code>这些节点在阴影树2中.
          </li>
          <li>
            <var>shadow tree(阴影树) 3</var> 托管给了<code>H</code>. 节点 <code>J</code>, <code>K</code>, <code>L</code> 和 <code>M</code>这些节点在阴影树3中.
          </li>
          <li>
            <var>shadow tree(阴影树) 4</var> 托管给了<code>K</code>. 节点 <code>N</code>, <code>O</code> 和 <code>P</code> 这些节点在阴影树4中.
          </li>
          <li>
            <var>shadow tree(阴影树) 5</var> 托管给了<code>O</code>. 节点 <code>Q</code> 和 <code>R</code> 这些节点在阴影树5中.
          </li>
          <li>
            <var>shadow tree(阴影树) 6</var> 托管给了<code>F</code>. 节点 <code>S</code>, <code>T</code> 和 <code>U</code> 这些节点在阴影树6中.
          </li>
          <li>
            <var>shadow tree(阴影树) 7</var> 托管给了<code>B</code>. 节点 <code>V</code>, <code>W</code> 和 <code>X</code> 这些节点在阴影树7中.
            <a>shadow tree(阴影树)</a> 7是比<var>shadow tree(阴影树) 2</var>更早生成的.
          </li>
        </ul>

        <p>
          让我们假设这颗<a>tree of trees(树)</a>的 <a>分布结果</a>是:
        </p>

        <ul>
          <li>
            <code>C</code><a>destination insertion points(目标插入点)</a>是 <code>[I, M]</code> (<code>C</code>是被重新分布的)
          </li>
          <li>
            <code>L</code><a>destination insertion points(目标插入点)</a>是 <code>[P, R]</code> (<code>L</code>是被重新分布的)
          </li>
          <li>
            <code>G</code><a>destination insertion points(目标插入点)</a>是 <code>[U]</code>
          </li>
          <li>
            <code>F</code><a>destination insertion points(目标插入点)</a>是 <code>[X]</code>
          </li>
        </ul>

        <p>
          在这种情况下, 如果一个事件在被分发到<code>D</code>上, 这个事件路径是:
        </p>
        <p>
          <code>
            [D, C, I, M, L, P, R, Q, O, N, K, J, H, G, U, T, S, F, E, X, W, V, B, A]
          </code>
        </p>

        <p>
          记录<a>event path calculation algorithm(事件路径的算法)</a> 是被设计用来实现以下目标:
        </p>

        <ol>
          <li>
            如果这里有节点, <var>CHILD(子节点)</var>在事件路径中并且<var>CHILD(子节点)</var>拥有父节点, <var>PARENT(父节点)</var>在节点树中, 事件路径也应该包括 <var>PARENT(父节点)</var>.
            <var>PARENT(父节点)</var>在事件路径中通常出现在<var>CHILD(子节点)</var>之后.
          </li>
          <li>
            在每一个<a>node tree(节点树)</a>中节点的事件路径来自于一个<em>直系祖先</em>. 在每一个<a>node tree(节点树)</a>中是没有<em>branch points(分支点)</em>的.
          </li>
        </ol>

        <figure>
          <object data="../../assets/images/event-path-node-trees.svg" width="884" height="473">></object>
          <figcaption>
            一个事件路径和节点树的关系. 在图中, 在每个节点被展示出来的左分支代表在事件路径中每一个节点最初起始的位置.
            在一个节点树中,一个父节点通常有大量比自身子元素更多的事件路径的起始位置.
          </figcaption>
        </figure>

        <p>
          这意味着如果我们获取一个<a>node tree(节点树)</a>的焦点并且忽视掉其他所有的 <a title="node tree">node trees(节点树)</a>,
          事件路径将似乎看上就好像事件发生在我们所获取焦点的<a>node tree(节点树)</a>上.
          这是一个非常重要的方面从某种意义上来说进行托管的阴影树在<em>包含</em><a>node tree(节点树)</a><a>shadow host(阴影树)</a>其中的情况下对于事件路径不具有任何影响
          只要这个事件没有在<a title="descendant tree">descendant trees(子树)</a>上被阻止.
        </p>

        <p>
          举个例子, 通过<var>document tree(文档树) 1</var>的视图, 事件路径看上去将会是<code>[D, C, B, A]</code>.
          通过<var>shadow tree(阴影树) 2</var>的视图, 事件路径看上去将会是<code>[I, H, G, F, E]</code>.
          这种相似情况同样会应用于 <a title="node tree">node trees(节点树)</a>.
        </p>

        <p>
          这也是值得我们指出的一种情况如果我们从事件路径中排除全部<a title="insertion point">insertion points(插入点)</a>和<a title="shadow root">shadow roots(阴影根)</a>,
          这种结果等价于包括所有的祖先节点在生成树中分发事件.
        </p>

        <figure>
          <object data="../../assets/images/event-path-and-composed-tree.svg" width="217" height="1723"></object>
          <figcaption>
            一个事件路径和<a>composed tree(生成树)</a>的关系. 事件路径使用了此例子中在左分支上个被展示出的节点同时<a>composed tree(生成树)</a>展示了右分支的节点.
            如果我们从事件路上上排除所有<a title="insertion point">insertion points(插入点)</a>和<a title="shadow root">shadow roots(阴影根)</a>,
            这种情况等价于在<a>composed tree(生成树)</a>中包含所有有祖先的节点, <code>D</code>.
          </figcaption>
        </figure>

      </section>

      <section>
        <h3>事件的重定向</h3>

        <p>在事件路径穿过大多数节点树的情况下, 事件信息包括事件的目标是被调整过的为了维持<a href="#encapsulation">encapsulation(封装性)</a>. 事件<dfn>retargeting(重定向)</dfn>是一个当事件在每一个有祖先的<a>节点</a>上被分发时去计算相关联的目标. 一个<dfn>relative target(相关联的目标)</dfn>是一个<a>node(节点)</a>,此给定了父元素的节点能最准确代表当前被分发事件的目标当保持封装性的时.</p>

        <p><dfn>retargeting algorithm(重定向算法)</dfn>被用来决定相关联的元素, 它<strong>must(必须)</strong> <a title="processing equivalence">equivalent(等价)</a>于经过下列的步奏:</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>EVENT-PATH(事件路径)</var>, an event path(一个事件路径)</dd>
            <dd><var>CURRENT-TARGET(当前的目标)</var>, 在某个地方是被事件监听所关联的一个<a>node(节点)</a>.</dd>
            <dt>Output</dt>
            <dd><var>RELATIVE-TARGET(相关联的目标)</var>, 调整后的目标</dd>
          </dl>
          <ol>
            <li>让<var>CURRENT-TARGET-TREE(当前目标树)</var>成为<a>node tree(节点树)</a>,<var>CURRENT-TARGET(当前目标)</var>在<a>其中</a></li>
            <li>让<var>ORIGINAL-TARGET(源目标)</var>成为<var>EVENT-PATH(路径)</var>中的第一项</li>
            <li>让<var>ORIGINAL-TARGET-TREE(源目标树)</var>成为<a>node tree(节点树)</a>,<var>ORIGINAL-TARGET(源目标)</var>在<a>其中</a></li>
            <li>让<var>RELATIVE-TARGET-TREE(相关联的目标树)</var>最小(<var>CURRENT-TARGET-TREE(当前目标树)</var>和<var>ORIGINAL-TARGET-TREE(源目标树)</var>之间拥有共同的<a>inclusive ancestor tree(包括祖先的元素)</a></li>
            <li>让<var>RELATIVE-TARGET(相关联的目标)</var> 成为第一个在<var>EVENT-PATH(事件路径)</var>中<a>node(节点)</a>,此节点需要满足以下条件:
              <ol>
                <li>此<a>node(节点)</a>必须<a>在</a><var>RELATIVE-TARGET-TREE(相关联的树)</var>中</li>
              </ol>
            </li>
          </ol>
        </div>

        <p>重定向过程<strong>必须</strong>发送在一个事件被分发之前.</p>
      </section>

      <section>
        <h3>重定向的 <code>关系目标</code></h3>

        <p>一些事件有一个<a><code>relatedTarget(关联目标)</code></a> [[!DOM-Level-3-Events]]属性,  这个属性是一个不是事件目标的<a>node(节点)</a>, 但是和事件有关系.</p>

        <p>举个实例, 一个<code>mouseover</code>事件的<a><code>relatedTarget(关联目标)</code></a>可能拥有一个<a>node(节点)</a>来自于鼠标被移动到事件<code>target(目标)</code>.在<code>relatedTarget(相关联目标)</code>是一个<a>shadow tree(阴影树)</a>的情况下, 符合标准的UAs <strong>必须</strong>不能把真是的值泄露出这颗树. 在<code>relatedTarget(相关联目标)</code>和<code>target(目标)</code>都属于相同<a>shadow tree(阴影树)</a>的一部分, 符合标准的UAs <strong>必须</strong> <em>阻止</em>在阴影根上的事件去避免出现在<code>mouseover</code> 和 <code>mouseout</code>事件触发来自于于同一节点的错误.</p>

        <p>因此, 如果一个事件有 <code>relatedTarget(相关联目标)</code>, 它的值和事件分发的范围 <strong>必须</strong>被调整. 通常来说:</p>
        <ol>
          <li>对于给定的一个节点, <code>relatedTarget(相关联的目标)</code> <strong>必须</strong>改为它的祖先 (或者它本身) 作为一个节点在同一个<a>shadow tree(阴影树)</a>中</li>
          <li>事件监听<strong>一定不能够</strong>在一个<a>node(节点)</a>上被调用,此时节点的<code>target(目标)</code>和<code>relatedTarget(相关联的目标)</code>是相同的.</li>
        </ol>

        <p><dfn>related target resolution algorithm(相关联目标分辨算法)</dfn> <strong>必须</strong>必须用来决定<a><code>relatedTarget(相关联目标)</code></a>属性的值并且<strong>必须</strong><a title="processing equivalence">equivalent(等价)</a>于经过下列步骤的处理:</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>EVENT(事件)</var>, 一个事件</dd>
            <dd><var>CURRENT-TARGET(当前的目标)</var>, 一个被事件监听所调用的<a>node(节点)</a></dd>
            <dd><var>RELATED-TARGET(相关联的目标)</var>, 被事件所关联到的目标</dd>
            <dt>输出</dt>
            <dd><var>ADJUSTED-RELATED-TARGET(调整过的相关联的目标)</var>, 相对于<var>CURRENT-TARGET(当前目标)</var><dfn>adjusted related target(调整后的目标)</dfn></dd>
          </dl>
          <ol>
            <li>让<var>CURRENT-TARGET-TREE(当前目标树)</var>成为一个包含<var>CURRENT-TARGET(当前目标)</var>的<a>node tree(节点树)</a></li>
            <li>让<var>RELATED-TARGET-TREE(关联目标树)</var>成为一个包含<var>RELATED-TARGET(关联目标)</var>的<a>node tree(节点树)</a></li>
            <li>让<var>RELATED-TARGET-EVENT-PATH(相关目标事件路径)</var>在<var>RELATED-TARGET(关联目标)</var>和<var>EVENT(事件)</var>中通过<a>event path calculation algorithm(事件路径算法)</a>的结果输出</li>
            <li>如果<var>CURRENT-TARGET-TREE(当前目标树)</var>和<var>RELATED-TARGET-TREE(关联目标树)</var>都在同一个<a>tree of trees(树)</a>:
              <ol>
                <li>让<var>LOWEST-COMMON-ANCESTOR-TREE(共有度最高的祖先树)</var>成为<var>CURRENT-TARGET-TREE(当前目标树)</var>和<var>RELATED-TARGET-TREE(关联目标树)</var>中<a>inclusive ancestor tree(包含的祖先树)</a>中共有度最高的 </li>
              </ol>
            </li>
            <li>否则:
              <ol>
                <li>让<var>LOWEST-COMMON-ANCESTOR-TREE(共有度最高的祖先树)</var>成为<var>RELATED-TARGET-TREE(相关联目标树)</var>的<a>root tree(根树)</a></li>
              </ol>
            </li>
            <li>对于每一个<a>inclusive ancestor tree(包含祖先的树)</a>, <var>COMMON-ANCESTOR-TREE(共有祖先的树)</var>, <var>LOWEST-COMMON-ANCESTOR-TREE(共有度最高的祖先树)</var>, 在递增的顺序上:
              <ol>
                <li>让<var>ADJUSTED-RELATED-TARGET(调整后的相关的目标)</var>成为<var>RELATED-TARGET-EVENT-PATH(相关目标事件路径)</var>中的第一个<a>node(节点)</a>只要符合以下的条件:
                  <ol>
                    <li><a>node(节点)</a> <a>包含在</a><var>COMMON-ANCESTOR-TREE(共同的祖先树)</var>中</li>
                  </ol>
                </li>
                <li>如果<var>ADJUSTED-RELATED-TARGET(调整后的相关的目标)</var>存在:
                  <ol>
                    <li>停止使用此算法</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </div>

        <p class="note">相关目标分辨算法的返回结果不总为null. 如果发生这种情况, 你需要对本标准提出bug并反馈给我们.</p>

        <p>相关目标重定向的过程<strong>必须</strong>必须发生在一个事件分发之前.</p>
      </section>

      <section>
        <h3>重定向触摸事件</h3>

        <p><a><code>Touch(触摸)</code></a> <a title="Touch target"><code>target(目标)</code></a> [[!TOUCH-EVENTS]] 属性必须被调整就像一个<a><code>relatedTarget(相关目标)</code></a>的一个事件. 每一个<a><code>Touch(触摸)</code></a> <a title="Touch target"><code>target(目标)</code></a>在<a><code>TouchList(触摸列表)</code></a>的返回结果来自于<a><code>TouchEvent(触摸事件)</code></a>的<a title="touches"><code>touches()</code></a>, <a title="changedTouches"><code>changedTouches()</code></a> 和<a title="targetTouches"><code>targetTouches()</code></a>的结果一定是经过<a>related target resolution algorithm(相关目标解析算法)</a>, 指定一个<var>NODE(节点)</var>和<a><code>Touch(触摸)</code></a> <a title="Touch target"><code>target(目标)</code></a>作为参数.</p>
      </section>

      <section>
        <h3>重定向得到焦点事件</h3>

        <p><code>focus(得到焦点)</code>, <code>DOMFocusIn</code>, <code>blur(失去焦点)</code>, 和<code>DOMFocusOut</code> 事件 <strong>必须</strong>被认为是和带有<code>relatedTarget(相关)</code>的事件是同一种方式的, 符合的<a>node(节点)</a>的相关联的目标是在<a>target(目标)</a>得到焦点时又失去焦点时使用失去焦点时的结果或者 <a>node(节点)</a>获得焦点, 同时又造成它失去焦点<code>target(目标)</code> 行为的节点作为相关联的目标.</p>
      </section>

      <section>
        <h3>事件分发</h3>

        <p>在分发事件的时候:</p>
        <ul>
          <li><a><code>Event(事件)</code></a> <a><code>target(目标)</code></a> 和 <a><code>currentTarget(当前目标)</code></a>的属性 <strong>必须</strong>返回一个<a>relative target(相关联的目标)</a>给<a>node(节点)</a>当节点的事件监听<a title="event listener invoke">invoked(被触发)</a></li>
          <li><a><code>MouseEvent(鼠标事件)</code></a>的<a><code>relatedTarget(相关目标)</code></a> 属性 <strong>必须</strong>返回一个<a>调整后的相关目标</a></li>
          <li><a><code>MouseEvent(鼠标事件)</code></a>的<a><code>offsetX</code></a> 和 <a><code>offsetY</code></a> 属性 <strong>必须</strong> 返回一个相对定位于坐标系初始<a>padding edge(边距边缘)</a>的<a>relative target(相关元素)</a>的坐标</li>
          <li><a><code>Touch(触摸)</code></a> <a title="Touch target"><code>target(目标)</code></a> 属性 <strong>必须</strong> 返回一个 <a>调整后的相关目标</a></li>
          <li>如果<a><code>relatedTarget(相关目标)</code></a>和<a><code>target(目标)</code></a>都指向同一个节点, 节点本身的事件监听<strong>一定不能</strong>被调用. <a><code>TouchEvent(触摸事件)</code></a>在这个规则上没有问题.</li>
          <li>当<em>capturing(事件捕获)</em>, 事件捕获必须要有<a title="event dispatch">event dispatch algorithm(事件分发算法)</a>步骤6的过程, 事件监听<strong>一定不能</strong>在<a>relative target(相关目标)</a>是自己本身节点的时候被<a title="event listener invoke">调用</a></li>
          <li>当<em>bubbling(事件冒泡)</em>, 事件冒泡必须要有<a title="event dispatch">event dispatch algorithm(事件分发算法)</a>步骤9的过程, <a><code>Event(事件)</code></a> <a>eventPhase(解析)</a> 属性 <strong>必须</strong> 返回一个 <a>AT_TARGET</a> <strong>如果</strong>是<a>relative target(相关元素)</a> 同<a>node(节点)</a>一样当事件监听<a title="event listener invoke">被调用</a></li>
          <li>如果事件<a><code>bubbles(冒泡)</code></a>的属性值是<strong>false</strong>, 必须经过以下步骤:
            <ol>
              <li>将<em>event path(事件路径)</em>的顺序倒序</li>
              <li>初始化事件的<a><code>eventPhase(事件解析)</code></a> 属性<a><code>AT_TARGET</code></a></li>
              <li>对于<em>event path(事件路径中)</em>的每一个对象，当<a>relative target(关联目标)</a>和对象相同, <a title="event listener invoke">调用</a>它自身的<a title="event listener">event listeners(事件监听)</a>, 在事件<em>处理</em>时, 只要<em>event(事件)</em>的 <a>停止冒泡的</a>没有设置</li>
            </ol></li>
        </ul>

        <p>在事件分发完成之上, <a><code>Event(事件)</code></a>对象 <a><code>target(目标)</code></a>和<a><code>currentTarget(当前目标)</code></a> <strong>一定</strong> 必须应该是最顶层的祖先<a>relative target(相关目标)</a>. 只要一段script可能控制了<code>Event</code>对象在事件分发的范围内的传递, 这个步骤需要去避免暴露在<a title="shadow tree">shadow trees(阴影树)</a>上的 <a title="node">nodes(节点)</a>.</p>
      </section>

      <section class="informative">
        <h3>事件重定向的示例</h3>

        <p>假设我们现在有一个媒体控件的用户实例, 通过下列这个树来描述它, 由<a>document tree(文档树)</a>和<a title="shadow tree">shadow trees(阴影树)</a>两部分组成. 在这个例子中, 我们将假设选择器被允许穿过阴影的边界并且我们将使用这些选择器去定义找到这些<a title="element">elements(元素)</a>. 当然, 我们也将创建一个虚构的<code>shadow-root(阴影根)</code> <a>element(元素)</a> 去划分阴影边界并且 表现出 <a title="shadow root">shadow roots(阴影根)</a>:</p>
        <pre class="example">
&lt;div id=&quot;player&quot;&gt;
    <span class=shadow-boundary>&lt;shadow-root id=&quot;player-shadow-root&quot;&gt;</span>
        &lt;div id=&quot;controls&quot;&gt;
            &lt;button id=&quot;play-button&quot;&gt;PLAY&lt;/button&gt;
            &lt;input type=&quot;range&quot; id=&quot;timeline&quot;&gt;
                <span class=shadow-boundary>&lt;shadow-root id=&quot;timeline-shadow-root&quot;&gt;</span>
                    &lt;div id=&quot;slider-thumb&quot; id=&quot;timeline-slider-thumb&quot;&gt;&lt;/div&gt;
                <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
            &lt;/input&gt;
            &lt;div id=&quot;volume-slider-container&quot;&gt;
                &lt;input type=&quot;range&quot; id=&quot;volume-slider&quot;&gt;
                    <span class=shadow-boundary>&lt;shadow-root id=&quot;volume-shadow-root&quot;&gt;</span>
                        &lt;div id=&quot;slider-thumb&quot; id=&quot;volume-slider-thumb&quot;&gt;&lt;/div&gt;
                    <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
&lt;/div&gt;
        </pre>

        <p>让我们通过一个选择器the volume slider's thumb (<code>#volume-slider-thumb</code>)去指出控件的位置, 由此 在这个节点上去触发 一个<code>mouseover</code> 事件. 对于这个事件, 让我们假装认为没有<code>relatedTarget(相关联的目标)</code>.</p>

        <p>每一个<a>retargeting algorithm(重定向算法)</a>, 我们都需要设置以下的祖先和相关联的目标:</p>
        <table>
          <thead>
            <tr>
              <th>Ancestor</th>
              <th>Relative Target</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>#player</code></td>
              <td><code><strong>#player</strong></code></td>
            </tr>
            <tr>
              <td><code>#player-shadow-root</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#controls</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-container</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider</code></td>
              <td><code><strong>#volume-slider</strong></code></td>
            </tr>
            <tr>
              <td><code>#volume-shadow-root</code></td>
              <td><code>#volume-slider-thumb</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-thumb</code></td>
              <td><code><strong>#volume-slider-thumb</strong></code></td>
            </tr>
          </tbody>
        </table>

        <p>在我们分发 <code>mouseover</code>这个事件之后 使用 它们新计算出来的相关联目标, 用户决定去通过拇指去移动设备的时间线的位置
          (<code>#timeline-slider-thumb</code>). 这次触发有一次<code>mouseout</code>事件对于the volume slider thumb 和一次<code>mouseover</code> 事件 对于 the timeline thumb.</p>

        <p>让我们看看the volume thumb's的<code>relatedTarget(相关联目标)</code>的值是如何被  <code>mouseout</code>事件所影响的. 对于这次事件, <code>relatedTarget(相关联事件)</code>是the timeline thumb (<code>#timeline-slider-thumb</code>). 每一次的<a>related target resolution algorithm(关联目标解析算法)</a>, 我们都应该设置以下的祖先和调整关联的目标:</p>

        <table>
          <thead>
            <tr>
              <th>Ancestor</th>
              <th>Relative Target</th>
              <th>Adjusted related Target</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>#player</code></td>
              <td><code><strong>#player</strong></code></td>
              <td><code><strong>#player</strong></code></td>
            </tr>
            <tr>
              <td><code>#player-shadow-root</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#controls</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-container</code></td>
              <td><code>#volume-slider</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider</code></td>
              <td><code><strong>#volume-slider</strong></code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-shadow-root</code></td>
              <td><code>#volume-slider-thumb</code></td>
              <td><code>#timeline</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-thumb</code></td>
              <td><code><strong>#volume-slider-thumb</strong></code></td>
              <td><code><strong>#timeline</strong></code></td>
            </tr>
          </tbody>
        </table>

        <p>节点, <code>#player</code>, <code>target(目标)</code> 和 <code>relatedTarget(关联目标)</code> 同时都有相同的值 (<code>#player</code>), 这意味着它们并没有分发 <a>node(节点)</a>和它们的祖先上分发事件.</p>
      </section>

    </section>

    <section>
      <h2>用户交互</h2>

      <section class="informative">
        <h3>范围 和 选区</h3>

        <p>
          <a>选区</a> [[!EDITING]]([[!可编辑的区域]])是没有被定义的. 选区的开发和实现应该做到最好. 这是一个可能公认的错误的方法:
        </p>

        <p>由于<a title="node">nodes(节点)</a>在不同的<a title="node tree">node(节点)树上</a>绝对不可能拥有相同的<a>根(元素)</a>,它们可能绝对不会存在一个有效的<a title="range">DOM范围内</a>(这个DOM范围包含了多数的<a title="node tree">node(节点)树)</a>.</p>

        <p>因此<a title="selection">选区</a> 是可能存在于唯一一个 <a>node(节点)树</a>里, 因为选区被定义在一个单独的<a>范围里</a>. 通过方法<code><a>window.getSelection()</a></code>返回的<a>选区</a>绝对不会返回一个在<a>shadow(阴影)树</a>里的<a>选区</a>.</p>

        <p><a>shadow(阴影)根</a>对象的<code>getSelection()</code>方法返回的是当前<a>选区</a>是在当前(上下文)的<a>shadow tree(阴影树)</a>.</p>
      </section>

      <section>
        <h3>引导获取焦点</h3>

        <p>如果一个<a>节点</a>不<a title="participates">加入</a>一个<a>生成树(composed tree)</a>,  <a>此节点</a> <strong>必须</strong>从[[!CSS3UI]]<a>渲染树的顺序</a>中被忽略</p>

        <p>对于<a>引导获取焦点的时序</a>, <a>此引导顺序</a>的时序对于一个给定的<a>shadow tree(阴影树)</a> <var>A</var> <strong>必须</strong> 被插入到其他<a>node tree(节点树)</a> <a>引导顺序中</a> , 规则规则如下:</p>
        <ol>
          <li>如果<var>A</var>是<a>最新的shadow tree(阴影树)</a>:
            <ol>
              <li>让<var>宿主</var>成为<a>shadow host(阴影宿主)</a>,现在的阴影宿主就是<a>宿主</a>A</li>
              <li>让<var>B</var>成为<a>node tree(节点树)</a>,<var>让节点树的宿主</var>加入</li>
              <li>对于A的<a>引导顺序</a> <strong>必须</strong> 将A插入到<var>B</var> <a>的引导顺序</a>:
                <ol>
                  <li>立刻插入到<var>宿主</var>之后, 如果<var>宿主</var>是<a>可聚焦的</a>; 或者</li>
                  <li>取代<var>此宿主</var> ，如果 <var>此宿主</var> 被指定了属性 <a title="nav-index auto"><code>auto</code>这个属性</a>(auto这个属性决定了此宿主的位置)</li>
                </ol></li>
            </ol></li>
          <li>如果不是那么:
            <ol>
              <li>让<var>B</var>成为一个<a>优先级较高的shadow tree(阴影树)</a> , 让B关联到<var>A</var></li>
              <li>让<var>SHADOW(阴影)</var>成为一个<a>shadow(阴影)插入点</a>插入 <var>B</var>中</li>
              <li>如果<var>SHADOW(阴影)</var> 存在, 在<var>SHADOW(阴影)</var>之后,对于<var>A</var>的<a>引导顺序</a><strong>必须</strong>被插入到<var>B</var>的<a>引导顺序</a>  如果<var>SHADOW(阴影)</var> 被指定了值 <a title="nav-index auto"><code>auto</code></a> 去决定它的位置.</li>
            </ol></li>
        </ol>

        <p>对于<a>有指向性的引导焦点</a>, 它取决于用户代理完整的  <a title="navigation order">引导顺序</a> 中 <a title="shadow tree">shadow trees(阴影树)</a> 在 <a>文本</a>中 <a>引导顺序</a>.</p>
      </section>

      <section>
        <h3>激活的元素</h3>

        <p>为了坚持封装性, <a>激活的元素</a>在<a title="Document object">文档</a>  对象的 focus(焦点) API 属性中的值 <strong>必须</strong>被调整的. 为了防止当调整这个值的时候丢失信息, 每一个 <a>shadow root(阴影的根)</a> <strong>必须</strong> 也拥有一个<code>激活元素的</code> 属性用来保存在<a>shadow tree(阴影树)</a>中获取焦点激活<a>元素的</a>属性值</p>

        <p>对于<dfn>激活 <a>元素</a> 的算法调整</dfn> 被用来决定<a>激活元素</a>的属性值,  激活元素<strong>必须</strong>经过如下列步骤一样的等价处理的过程:</p>

        <div class="algorithm">
          <dl>
            <dt>输入</dt>
            <dd><var>元素</var>, 得到焦点的<a>元素</a></dd>
            <dd><var>ROOT(根)</var>, 要么是一个<a>文档</a> 或者是一个 <a>shadow root(阴影根)</a></dd>
            <dt>输出</dt>
            <dd><var>校正</var>, 一个已经被校正的<a>激活元素</a>属性的<var>根</var>.</dd>
          </dl>
          <ol>
            <li>让 <var>路径</var><var>元素和null</var>的<a>事件路径算法结果</a>作为输入</li>
            <li>让 <var>调整</var>过的<var>路径</var>和<var>根</var>的<a>重定向算法结果</a> 作为输出</li>
          </ol>
        </div>
      </section>

      <section>
        <h3>校订</h3>

        <p><a><code>contenteditable</code>属性的值</a><strong>一定不能通过<a>shadow host(阴影宿主)</a> </strong> 传播到它本身的 <a title="shadow tree">shadow trees(阴影树)</a>上.</p>
      </section>

      <section>
        <h3>辅助技术</h3>

        <p>用户代理可以通过辅助技术遍历<a>composed tree(生成树)</a>, 因此可以使完整的WAI-ARIA(可访问的富因特网应用程序) [[!WAI-ARIA]]语义在<a title="shadow tree">shadow trees(阴影树)</a>中使用.</p>

      </section>

    </section>

    <section>
      <h2>Shadow Trees(阴影树)中的HTML元素</h2>

      <p>相对来说, 一个<a>shadow tree(阴影树)</a>可以看作是存在于<em>部分<a>文档</a></em>和文档本身之间某处的一个<a title="interface DocumentFragment">文档碎片</a>. 当阴影树被渲染的时候, 单个<a>shadow tree(阴影树)</a> 目的是维持它本身在<a>文档</a>的传统<a>树</a>中的标准. 于此同时, 由于阴影树是抽象封装, 阴影树不能影响<a>文档树</a>. 因此, 阴影树中的<a>HTML元素</a> <strong>必须</strong> 表现为指定的 [[!HTML]]的行为在<a title="shadow tree">shadow trees(阴影树)</a>中, 除了少数例外的情况</p>

      <section>
        <h3>无效的HTML元素</h3>

        <p><a>HTML元素</a>一个子集合<strong>确定</strong> 行为表现为 <dfn>无效</dfn>, 或者不属于<a>document tree(文档树)</a>. 在这种一致的<a title="interface DocumentFragment">document fragment(文档碎片)</a>中的这种<a>HTML元素</a>如何表现. 这样 <a title="element">elements(元素)</a>有:</p>
        <ul>
          <li><a title="base element"><code>base</code></a></li>
          <li><a title="link element"><code>link</code></a></li>
        </ul>

        <p>剩下的其他<a>HTML元素</a>在<a title="shadow tree">shadow trees(阴影树)里</a> <strong>必须</strong> 表现为就像它们出现在<a>document tree(文档树)</a>中的表现.</p>
      </section>

    </section>

    <section>
      <h2>HTML元素和它们的shadow trees(阴影树)</h2>

      <p>每一个 <a title="HTML">规范</a>, 针对内容的渲染地方，一些<a>HTM元素</a>不是用来渲染它们的内容或针对特殊的需求所设计的. 是为了标准化HTML元素在<a>composed tree(生成树)</a>中渲染时的不同行为的,在<a>shadow tree(阴影树)</a>被创建和被填充进去的实例化<a>元素</a>的时候,所有的HTML元素<strong>必须</strong>具有<a title="processing equivalence">相同</a>的阴影树.这取决于用户代理定义阴影树.当然, 所有符合标准的用户代理<strong>必须</strong>满足以下的要求:</p>

      <table>
        <thead>
          <tr>
            <th style="width: 30%">HTML Element</th>
            <th>Shadow Tree Requirements</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><a title="img element"><code>img</code></a>, <a title="iframe element"><code>iframe</code></a>, <a title="embed element"><code>embed</code></a>, <a title="object element"><code>object</code></a>, <a title="video element"><code>video</code></a>, <a title="audio element"><code>audio</code></a>, <a title="canvas element"><code>canvas</code></a>, <a title="map element"><code>map</code></a>, <a title="input element"><code>input</code></a>, <a title="textarea element"><code>textarea</code></a>, <a title="progress element"><code>progress</code></a>, <a title="meter element"><code>meter</code></a></td>
            <td>如果这些<a>元素</a>可能有<a>回调的内容</a>, 包含一个<a>内容的插入点</a>. 这个(内容的插入点的)<a>匹配条件</a>的值<a>是一个通用的选择器</a>紧紧当这些<a>元素</a>需要展示<a>回调内容</a>时.其它方面, 包含没有<a title="content insertion point">内容插入点</a> 或者一个<a>内容插入点</a>什么都无法匹配.</td>
          </tr>
          <tr>
            <td><a title="fieldset element"><code>fieldset</code></a></td>
            <td>包含两个<a title="content insertion point">内容的插入点</a>要符合下列<a>匹配条件</a>:
              <ol>
                <li><code>legend:first-of-type</code></li>
                <li><a>universal selector(普通选择符)</a></li>
              </ol>
            </td>
          </tr>
          <tr>
            <td><a title="details element"><code>details</code></a></td>
            <td>包含两个<a title="content insertion point">内容的插入点</a>要符合下列<a>匹配条件</a>:
              <ol>
                <li><code>summary:first-of-type</code></li>
                <li><a>universal selector(普通选择符)</a></li>
              </ol>
            </td>
          </tr>
          <tr>
            <td>剩下所有<a title="element">elements(元素)</a></td>
            <td>包含一个<a>内容插入点</a>并且有<a>universal selector(普通选择符)</a>作为<a>匹配条件</a></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2>Elements(元素)和DOM Objects(DOM对象)</h2>

      <section>
        <h3><code>ShadowRoot(阴影根)</code>对象</h3>

        <p><code>ShadowRoot(阴影根)</code>对象代表此<a>shadow root(阴影根)</a>.</p>

        <dl class="idl" title="interface ShadowRoot : DocumentFragment">
          <dt>HTMLElement getElementById(DOMString elementId)</dt>
          <dd>
            <strong>必须</strong>行为完全就像<a>document.getElementById</a>一样, 除了<a title="scoping constraints">scoped(作用域)</a>范围是在此<a>shadow tree(阴影树)</a>内.
          </dd>

          <dt>NodeList getElementsByClassName(DOMString className)</dt>
          <dd>
            <strong>必须</strong>行为完全就像<a>document.getElementsByClassName</a>一样, 除了<a title="scoping constraints">scoped(作用域)</a>范围是在此<a>shadow tree(阴影树)</a>.
          </dd>

          <dt>NodeList getElementsByTagName(DOMString tagName)</dt>
          <dd>
            <strong>必须</strong>行为完全就像<a>document.getElementsByTagName</a>, 除了<a title="scoping constraints">scoped(作用域)</a>范围是在此<a>shadow tree(阴影树)</a>.
          </dd>

          <dt>NodeList getElementsByTagNameNS(DOMString? namespace, DOMString localName)</dt>
          <dd>
            <strong>必须</strong>行为完全就像<a>document.getElementsByTagNameNS</a>, 除了<a title="scoping constraints">scoped(作用域)</a>范围是在此<a>shadow tree(阴影树)</a>.
          </dd>

          <dt>Selection? getSelection()</dt>
          <dd>
            <p>返回当前在此<a>shadow tree(阴影树)</a>的区域</p>
            <p>当此方法被调用, 它<strong>必须</strong>返回此<a>shadow tree(阴影树)</a>的<a>selection(区域)</a>.</p>
          </dd>

          <dt>Element? elementFromPoint(double x, double y)</dt>
          <dd>
            <p>返回一个<a>element(元素)</a>指定的坐标系.</p>
            <p class="note">最终, 它需要是CSSOM View Module[[!CSSOM-VIEW]]标准的一部分</p>
            <p>
              当此方法被调用, 它<strong>必须</strong>返回下列步骤运行后的结果:
            </p>
            <ol>
              <li>如果<a>context object(上下文对象)</a>不是一个<a><code>ShadowRoot(阴影根)</code></a>的实例, 那么抛出一个<a><code>InvalidNodeTypeError(无效节点的错误)</code></a>错误.</li>
              <li>如果其中任意一个参数无效, <code>x</code>大于<a>viewport(视窗)</a>的宽度不包括已经被渲染出来的滚动条(如果有), 或者如果是<code>y</code>大于<a>viewport(视窗)</a>的高度不包括已经被渲染出来的滚动条(如果有), 返回<strong>null</strong>.</li>
              <li>让<var>HIT</var>这样的方式成为描述<a>element(元素)</a>在<a>viewport(视窗)</a>中<code>X</code>和<code>Y</code>坐标, 这样的方式决定于是否通过打点测试</li>
              <li>让<var>PATH(路径)</var>在<a>HIT</a>里通过<a>event path calculation algorithm(事件路径算法)</a>所得到的结果HRnull作为输入</li>
              <li>返回通过<a>retargeting algorithm(重定向算法)</a>所得到的结果<var>PATH(路径)</var>和<a>context object(上下文对象)</a>作为输入</li>
            </ol>
          </dd>

          <dt>只读 attribute Element? activeElement</dt>
          <dd>
            <p>表示当前在<a>shadow tree(阴影树)</a>得到焦点的<a>element(元素)</a></p>
            <p>当读取时, 这个属性<strong>必须</strong>返回在当前在<a>shadow tree(阴影树)</a>中得到焦点的<a>element(元素)</a>的属性或者为<code>null</code>, 如果这个属性不是空的.</p>
          </dd>

          <dt>只读 attribute Element host</dt>
          <dd>
            <p>表示此<a>shadow host(阴影宿主)</a>,此<a>hosts(宿主)</a>有此<a>context object(上下文对象)</a>.</p>
            <p>当读取时, 这个属性<strong>必须</strong>返回此<a>shadow host(宿主)</a>,这个<a>hosts(宿主)</a>有此<a>context object(上下文对象)</a>.</p>
          </dd>

          <dt>只读 attribute ShadowRoot? olderShadowRoot</dt>
          <dd>
            <p>表示此<a>older shadow root(不是最新的阴影根)</a>所关联到此<a>context object(上下文对象)</a></p>
            <p>
              当读取时, 此属性<strong>必须</strong>返回一个<a title="processing equivalence">equivalent(等价)</a>于下列步骤运行后的结果:
            </p>
            <ol>
              <li>如果此<a>context object(上下文对象)</a>是在<a>oldest shadow root(最原始的阴影根)</a>, 返回<strong>null</strong>.</li>
              <li>返回一个<a>older shadow root(不是最新的阴影根)</a>所关联到的<a>context object(上下文对象)</a>.</li>
            </ol>
            <p>对于<a>HTML elements(HTML元素)</a>, <a href="#html-elements-and-their-shadow-trees">UA-provided</a> <a title="shadow tree">shadow trees(阴影树)</a> <strong>一定是</strong>不能被使用的.</p>
          </dd>

          <dt>attribute DOMString innerHTML</dt>
          <dd>
            <p>表示<a><code>ShadowRoot(阴影根)</code></a>的标记上下文.</p>
            <p>当读取该属性时, 此属性<strong>必须</strong>返回在此<a>context object(上下文对象)</a>中通过<a>HTML fragment serialization algorithm(HTML文档序列化算法)</a>所处理过的结果作为 <a title="shadow host"><code>shadow host(阴影宿主)</code></a></p>
            <p>
              当设置该属性时,<strong>必须</strong>经过以下步骤:
            </p>
            <ol>
              <li>让<var>FRAGMENT(片段)</var>经过调用<a title="parse fragment">fragment parsing algorithm(片段解析算法)</a> [[!DOMPARSING]]使新设置的值作为<var>MARKUP(标识)</var>的结果, 并且此<a>context object(上下文对象)</a>作为<a title="shadow host"><code>shadow host(阴影宿主)</code></a></li>
              <li><a>Replace all(替换所有)</a>在<a>shadow root(阴影根)中的<var>FRAGMENT(片段)</var></a></li>
            </ol>
          </dd>

          <dt>只读 attribute StyleSheetList styleSheets</dt>
          <dd>
            <p>表示此<a>shadow root(阴影根)的样式列表</a>.</p>
            <p>当读取该属性事时, 此属性<strong>必须</strong>返回一个<a><code>StyleSheetList(样式表)</code></a>序列包含此<a>shadow root(阴影根)的样式表</a>.
            </p>
          </dd>
        </dl>

        <p>一个<a><code>ShadowRoot(阴影根)</code></a> 实例的 <a><code>nodeType(节点类型)</code></a>属性 <strong>必须</strong> 返回 <a><code>DOCUMENT_FRAGMENT_NODE</code></a>. 因此, 一个<a><code>ShadowRoot(阴影根)</code></a>实例的<a><code>nodeName(节点名)</code></a> 属性<strong>必须</strong>返回<code>"#document-fragment"</code>.</p>

        <p>调用方法<a><code>cloneNode()</code></a>方法去复制<a><code>ShadowRoot(阴影根)</code></a> 实例时 <strong>必须</strong>通常会抛出一个 <a><code>DATA_CLONE_ERR</code></a>异常.</p>

      </section>

      <section>
        <h3><code>Element(元素)</code>接口的扩展</h3>

        <dl class="idl" title="partial interface Element">
          <dt>ShadowRoot(阴影根)方法createShadowRoot()</dt>
          <dd>
            当此方法被调用, <strong>必须经过</strong>以下的步奏:
            <ol>
              <li>创建一个新的<a><code>ShadowRoot(阴影根)</code></a>对象实例</li>
              <li>增加此<a><code>ShadowRoot(阴影根)</code></a>对象到一个<a title="shadow roots list">有序的阴影根列表上</a>根关联上的此<a>context object(上下文对象)</a>作为最新的<a>shadow root(阴影根)</a></li>
              <li>返回一个<a><code>ShadowRoot(阴影根)</code></a>对象.</li>
            </ol>
          </dd>

          <dt>NodeList(节点列表) getDestinationInsertionPoints()</dt>
          <dd>当此方法被调用, 此方法<strong>必须</strong>返回一个<a>static(静态)</a>的<a><code>NodeList(节点列表)</code></a>由在<a>destination insertion points(目标插入点)</a>中的<a title="insertion point">插入点</a>的<a>context object(上下文对象)</a>所组成的.</dd>
      </section>

      <section>
        <h3>元素的<code>content(内容)</code></h3>

        <p>元素的<code><dfn title="content element">content(内容)</dfn></code>表示一个在<a>shadow tree(阴影树)</a>中的<a>insertion point(插入点)</a>.</p>

        <p>如果一个<code>content(内容)</code>元素不符合<a>insertion point(插入点)</a>的条件, </p>

        <dl>
          <dt>上下文</dt>
          <dd>预计<a>flow content(流内容)</a>.</dd>

          <dt>内容模块</dt>
          <dd><a>可见的</a></dd>

          <dt>内容的子元素</dt>
          <dd>一切可以作为回调的内容</dd>

          <dt>内容的属性</dt>
          <dd><a>全局属性</a></dd>
          <dd>
            <dl>
              <dt><code><dfn title="content element select">select(选择)</dfn></code>, 设置一个<a title="comma separated tokens">comma-separated tokens(对于逗号分割的标识)</a></dt>
              <dd>表示用于<a title="distribution">distributing(分发)</a><a>shadow host(宿主对象)</a>中的子<a title="node">nodes(节点)</a><a>matching criteria(匹配标准)</a>. 每一个标识<strong>必须</strong>是一个<a>compound selector(复合的选择器)</a>.</dd>
            </dl>
          </dd>

          <dt>DOM接口</dt>
          <dd>
            <dl class="idl" title="interface HTMLContentElement : HTMLElement">
              <dt>attribute DOMString select</dt>
              <dd><strong>必须</strong> <a>显示</a>此<a title="content element select">select(选择)</a>属性.</dd>

              <dt>NodeList getDistributedNodes()</dt>
              <dd>
                当此方法被调用, 它<strong>必须返回</strong>一个经过下列步骤的结果:
                <ol>
                  <li>
                    如果此<a>context object(上下文对象)</a>是一个<a>内容插入点</a>:
                    <ol>
                      <li>返回一个<a>静态</a>的<a><code>NodeList(节点列表)</code></a>由在<a>context object(上下文对象)</a>中<a>distributed nodes(分布的节点)</a>所组成的</li>
                    </ol>
                  </li>
                  <li>
                    其它情况:
                    <ol>
                      <li>返回一个空的<a>static(静态)</a> <a><code>NodeList(节点列表)</code></a>对象.</li>
                    </ol>
                  </li>
                </ol>
              </dd>
            </dl>
          </dd>
        </dl>
      </section>

      <section>
        <h3><code>shadow(阴影)</code>元素</h3>

        <p><code><dfn title="shadow element">shadow(阴影)</dfn></code>元素表示在<a>shadow tree(阴影树)</a>中的一个<a>shadow insertion point(阴影插入点)</a>.</p>
        <p>如果一个<code>shadow(阴影)</code>元素不满足<a>insertion point(插入点)</a>的条件, 它<strong>必须</strong>就像<a><code>HTMLUnknownElement(未知HTML元素)</code></a>一样的渲染行为.</p>

        <dl>
          <dt>上下文</dt>
          <dd>预计的<a>流内容</a>.</dd>

          <dt>内容模块</dt>
          <dd><a>可见的</a></dd>

          <dt>阴影元素的子元素</dt>
          <dd>可以是一切</dd>

          <dt>DOM接口</dt>
          <dd>
            <dl class="idl" title="interface HTMLContentElement : HTMLElement">
              <dt>attribute DOMString select</dt>
              <dd><strong>必须</strong> <a>显示</a>此<a title="content element select">select(选择)</a>属性.</dd>

              <dt>NodeList getDistributedNodes()</dt>
              <dd>
                当此方法被调用, 它<strong>必须返回</strong>一个经过下列步骤的结果:
                <ol>
                  <li>
                    如果此<a>context object(上下文对象)</a>是一个<a>内容插入点</a>:
                    <ol>
                      <li>返回一个<a>静态</a>的<a><code>NodeList(节点列表)</code></a>由在<a>context object(上下文对象)</a>中<a>distributed nodes(分布的节点)</a>所组成的</li>
                    </ol>
                  </li>
                  <li>
                    其它情况:
                    <ol>
                      <li>返回一个空的<a>static(静态)</a> <a><code>NodeList(节点列表)</code></a>对象.</li>
                    </ol>
                  </li>
                </ol>
              </dd>
            </dl>
          </dd>
        </dl>
      </section>

      <section>
        <h3>异常的<code>Event(事件)的</code>接口</h3>

        <dl class="idl" title="partial interface Event">
          <dt>只读 attribute object path</dt>
          <dd>
            <p>表示此事件对象路径.</p>
            <p>
              当获取该属性时, 此属性<strong>必须</strong> 创建和返回一个新的JavaScript数组对象, 此数组对象从<a>context object(上下文对象)</a>的事件路径中拷贝而来.
            </p>
            <p class="issue">
              使用<code>Array(数组)</code> 作为在WebIDL中返回类型的<code>path(路径)</code>属性.
              WebIDL的bugs: <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20020"><code>Array</code>subclassing</a>
              和<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=23225"> class, not interface</a>.
            </p>
          </dd>
        </dl>
      </section>

    </section>

    <section>
      <h2>Shadow DOM示例</h2>

      <p>Bob被要求在把一个简单的链接列表变成一个消息控件,  消息控件能够连接到2个不同类别的新闻: 突发新闻和最新新闻. 目前新闻报道的文档组成看上去就像这样:</p>
      <pre class="example highlight">
&lt;ul class=&quot;stories&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/1&quot;&gt;A story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/2&quot;&gt;Another story&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;breaking&quot;&gt;&lt;a href=&quot;//example.com/stories/3&quot;&gt;Also a story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/4&quot;&gt;Yet another story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/4&quot;&gt;Awesome story&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;breaking&quot;&gt;&lt;a href=&quot;//example.com/stories/5&quot;&gt;Horrible story&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      </pre>

      <p>为了管理新闻报道, Bob决定使用<strong>shadow DOM</strong>. 这样做允许Bob保持整个标签的整洁, 拥有可以控制插入点的权会使得通过类名分类新闻的任务变的非常简单. 在得到一杯<a href="http://en.wikipedia.org/wiki/List_of_coffee_beverages#Green_Eye">Green Eye</a>后, 他制作出了如下shadow tree(阴影树),<code>ul</code>元素成为了宿主:</p>
      <pre class="example highlight">
&lt;div class=&quot;breaking&quot;&gt;
    &lt;ul&gt;
        &lt;content select=&quot;.breaking&quot;&gt;&lt;/content&gt; &lt;!-- insertion point for breaking news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;other&quot;&gt;
    &lt;ul&gt;
        &lt;content&gt;&lt;/content&gt; &lt;!-- insertion point for the rest of the news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
      </pre>
      <p>Bob接下来根据来自于设计师的要求给新建立的消息控件样式，然后把它加入到shadow tree(阴影树)模型中:</p>
      <pre class="example highlight">
&lt;style&gt;
    div.breaking {
        color: Red;
        font-size: 20px;
        border: 1px dashed Purple;
    }
    div.other {
        padding: 2px 0 0 0;
        border: 1px solid Cyan;
    }
&lt;/style&gt;
      </pre>
      <p>他仔细考虑了下他的公司是否应该找一个新的设计师, Bob将模型转化成了代码:</p>
      <pre class="example highlight">
function createStoryGroup(className, contentSelector)
{
    var group = document.createElement('div');
    group.className = className;
    // Empty string in select attribute or absence thereof work the same, so no need for special handling.
    group.innerHTML = '&lt;ul&gt;&lt;content select=&quot;' + contentSelector + '&quot;&gt;&lt;/content&gt;&lt;/ul&gt;';
    return group;
}

function createStyle()
{
    var style = document.createElement('style');
    style.textContent = 'div.breaking { color: Red;font-size: 20px; border: 1px dashed Purple; }' +
        'div.other { padding: 2px 0 0 0; border: 1px solid Cyan; }';
    return style;
}

function makeShadowTree(storyList)
{
    var root = storyList.createShadowRoot();
    root.appendChild(createStyle());
    root.appendChild(createStoryGroup('breaking', '.breaking'));
    root.appendChild(createStoryGroup('other', ''));
}

document.addEventListener('DOMContentLoaded', function() {
    [].forEach.call(document.querySelectorAll('ul.stories'), makeShadowTree);
});
      </pre>

      <p>干得好, Bob! 在咖啡还有半杯的情况下, 工作完成了. 意识到自己很厉害, Bob将自己的经验通过<a href="http://en.wikipedia.org/wiki/Puyo_Puyo_(series)">Puyo Puyo</a>这样的方式传授给大家.</p>

      <p>几个月过去了.</p>

      <p>红旗飘飘了！ 在Bob一年一度的研讨会中, Alice 负责增加 <strong>另一个</strong>, 临时的盒子在新闻控件中, 其中有许多关于选举的新闻. Alice阅读学习了Bob's代码, 阅读了shadow DOM的标准并且实现了, 多亏shadow tree(阴影树)复合的支持, 她并没有修改Bob的代码. 就像平常一样, 她的解决方法优雅而简单, 适当的在Bob的代码上做了点巧妙的变化:</p>
      <pre class="example highlight">
// TODO(alice): BEGIN -- DELETE THIS CODE AFTER ELECTIONS ARE OVER.
var ELECTION_BOX_REMOVAL_DEADLINE = ...;

function createElectionStyle()
{
    var style = document.createElement('style');
    // TODO(alice): Check designer's desk for hallucinogens.
    style.textContent = 'div.election { color: Magenta; font-size: 24px; border: 2px dotted Fuchsia; }';
    return style;
}

function makeElectionShadowTree(storyList)
{
    var root = storyList.createShadowRoot();
    // Add and style election story box.
    root.appendChild(createElectionStyle());
    root.appendChild(createStoryGroup('election', '.election'));
    // Insert Bob's shadow tree under the election story box.
    root.appendChild(document.createElement('shadow'));
}

if (Date.now() &lt; ELECTION_BOX_REMOVAL_DEADLINE) {
    document.addEventListener('DOMContentLoaded', function() {
        [].forEach.call(document.querySelectorAll('ul.stories'), makeElectionShadowTree);
    });
}
// TODO(alice): END -- DELETE THIS CODE AFTER ELECTIONS ARE OVER.
      </pre>
      <p>使用<code>shadow(阴影)</code> 元素允许Alice去组合Bob's组件<strong>到自己的组件里</strong>&mdash;在没有改变产品任何一行代码的情况下. 她对自己笑了, Alice意识到Bob已经想出一个方式关于保持文档标签整洁的想法, 但<strong>她</strong>是一个如此早的使用shadow tree(阴影树)组成这种很酷的方式去解决问题的人.</p>
    </section>

    <section class="appendix">
      <h2>致谢</h2>

      <p><span class="vcard">David Hyatt</span> 开发了 <a href="http://dev.w3.org/2006/xbl2/">XBL 1.0</a>, 并且和<span class="vcard">Ian Hickson</span>合写了<a href="http://dev.w3.org/2006/xbl2/">XBL 2.0</a>. 这两篇文档提供了极好的见解在函数闭包的问题并对本规范产生了巨大的影响.</p>

      <p><span class="vcard">Alex Russell</span>和他非常有远见的想法引发了在shadow Dom这个主题上引发了狂热的浪潮和如何在web中实际应用起来.</p>

      <p><span class="vcard">Dominic Cooney</span>, <span class="vcard">Hajime Morrita</span>, and <span class="vcard">Roland Steiner</span>不辞辛劳的工作在web平台范围里去解决函数闭包问题并且为这篇文档提供了稳固的基础.</p>

      <p>编者也感谢像<span class="vcard">Alex Komoroske</span>, <span class="vcard">Anne van Kesteren</span>, <span class="vcard">Brandon Payton</span>, <span class="vcard">Brian Kardell</span>, <span class="vcard">Darin Fisher</span>, <span class="vcard">Eric Bidelman</span>, <span class="vcard">Deepak Sherveghar</span>, <span class="vcard">Edward O'Connor</span>, <span class="vcard">Elisée Maurer</span>, <span class="vcard">Elliott Sprehn</span>, <span class="vcard">Erik Arvidsson</span>, <span class="vcard">Glenn Adams</span>, <span class="vcard">Jonas Sicking</span>, <span class="vcard">Malte Ubl</span>, <span class="vcard">Mike Taylor</span>, <span class="vcard">Oliver Nightingale</span>, <span class="vcard">Olli Pettay</span>, <span class="vcard">Rafael Weinstein</span>, <span class="vcard">Richard Bradshaw</span>, <span class="vcard">Ruud Steltenpool</span>, <span class="vcard">Sam Dutton</span>, <span class="vcard">Sergey G. Grekhov</span>, <span class="vcard">Shinya Kawanaka</span>, <span class="vcard">Tab Atkins</span>, <span class="vcard">Takashi Sakamoto</span>, and <span class="vcard">Yoshinori Sano</span>，感谢他们对此标准的意见和协助.</p>

      <p>此标准仍不完善. 还有许多工作需要做. 请通过阅读帮助我们并且记录bugs&mdash;千万不要忘记叫编者将你的名字添加到这里来.</p>
    </section>

  </body>
</html>
